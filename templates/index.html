<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sailing Track Visualizer</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #map {
            flex: 1;
            width: 100%;
        }

        .controls {
            background: white;
            padding: 15px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #speed-slider {
            width: 150px;
        }

        .info {
            font-size: 14px;
            color: #333;
        }

        .boat-icon {
            text-align: center;
            font-size: 24px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading tracks...</div>
    <div id="map"></div>

    <div class="controls">
        <button id="play-btn">Play</button>
        <button id="pause-btn" disabled>Pause</button>
        <button id="reset-btn">Reset</button>

        <div class="speed-control">
            <label for="speed-slider">Speed:</label>
            <input type="range" id="speed-slider" min="1" max="10" value="5" />
            <span id="speed-value">5x</span>
        </div>

        <div class="info">
            <span id="progress-info">Ready to play</span>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        let map;
        let tracks = [];
        let bounds = null;
        let twsRange = null;
        let allPoints = [];
        let currentIndex = 0;
        let animationInterval = null;
        let boatMarker = null;
        let trackPolylines = [];
        let animationPolyline = null;
        let speed = 5;

        // Initialize the map
        async function initMap() {
            try {
                // Fetch track data
                const response = await fetch('/api/tracks');
                const data = await response.json();
                tracks = data.tracks;
                bounds = data.bounds;
                twsRange = data.tws_range;

                // Hide loading indicator
                document.getElementById('loading').style.display = 'none';

                // Create map centered on the tracks
                if (bounds) {
                    map = L.map('map').setView(
                        [bounds.center_lat, bounds.center_lon],
                        13
                    );
                } else {
                    map = L.map('map').setView([38.92, 20.89], 13);
                }

                // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                // Draw all tracks on the map with color based on RPM and TWS
                tracks.forEach((track, index) => {
                    // Draw segments based on RPM and TWS
                    for (let i = 0; i < track.points.length - 1; i++) {
                        const p1 = track.points[i];
                        const p2 = track.points[i + 1];

                        let color;
                        // If either point has RPM = 0, draw black
                        if (p1.rpm === 0 || p2.rpm === 0) {
                            color = 'black';
                        } else {
                            // Use tws-based color when engine is running
                            // Average the tws values of the two points
                            const avgTws = (p1.tws + p2.tws) / 2;
                            color = getTwsColor(avgTws);
                        }

                        const segment = L.polyline(
                            [[p1.lat, p1.lon], [p2.lat, p2.lon]],
                            {
                                color: color,
                                weight: 3,
                                opacity: 0.7
                            }
                        ).addTo(map);
                        trackPolylines.push(segment);
                    }

                    // Add start marker
                    if (track.points.length > 0) {
                        const start = track.points[0];
                        L.circleMarker([start.lat, start.lon], {
                            radius: 5,
                            color: 'green',
                            fillColor: 'green',
                            fillOpacity: 1
                        }).addTo(map).bindPopup(`Start: ${track.name}`);
                    }

                    // Add end marker
                    if (track.points.length > 0) {
                        const end = track.points[track.points.length - 1];
                        L.circleMarker([end.lat, end.lon], {
                            radius: 5,
                            color: 'red',
                            fillColor: 'red',
                            fillOpacity: 1
                        }).addTo(map).bindPopup(`End: ${track.name}`);
                    }

                    // Collect all points for animation
                    track.points.forEach(point => {
                        allPoints.push({
                            ...point,
                            trackName: track.name
                        });
                    });
                });

                // Fit map to bounds
                if (bounds) {
                    map.fitBounds([
                        [bounds.min_lat, bounds.min_lon],
                        [bounds.max_lat, bounds.max_lon]
                    ]);
                }

                // Create boat marker (initially hidden)
                const boatIcon = L.divIcon({
                    className: 'boat-icon',
                    html: 'â›µ',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                });

                if (allPoints.length > 0) {
                    boatMarker = L.marker(
                        [allPoints[0].lat, allPoints[0].lon],
                        { icon: boatIcon }
                    ).addTo(map);
                }

                // Initialize animation polyline
                animationPolyline = L.polyline([], {
                    color: 'blue',
                    weight: 3,
                    opacity: 0.8
                }).addTo(map);

            } catch (error) {
                console.error('Error loading tracks:', error);
                document.getElementById('loading').textContent = 'Error loading tracks!';
            }
        }

        // Cold ice / hot metal colormap
        // Maps a value from 0-1 to a color in the cold ice to hot metal range
        function getColorFromValue(value) {
            // Clamp value between 0 and 1
            value = Math.max(0, Math.min(1, value));

            // Cold ice (blue/cyan) to hot metal (red/yellow/white)
            // Blue -> Cyan -> Green -> Yellow -> Orange -> Red -> White
            if (value < 0.2) {
                // Blue to Cyan
                const t = value / 0.2;
                const r = 0;
                const g = Math.floor(t * 255);
                const b = 255;
                return `rgb(${r}, ${g}, ${b})`;
            } else if (value < 0.4) {
                // Cyan to Green
                const t = (value - 0.2) / 0.2;
                const r = 0;
                const g = 255;
                const b = Math.floor(255 * (1 - t));
                return `rgb(${r}, ${g}, ${b})`;
            } else if (value < 0.6) {
                // Green to Yellow
                const t = (value - 0.4) / 0.2;
                const r = Math.floor(t * 255);
                const g = 255;
                const b = 0;
                return `rgb(${r}, ${g}, ${b})`;
            } else if (value < 0.8) {
                // Yellow to Orange/Red
                const t = (value - 0.6) / 0.2;
                const r = 255;
                const g = Math.floor(255 * (1 - t * 0.5));
                const b = 0;
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // Orange/Red to White
                const t = (value - 0.8) / 0.2;
                const r = 255;
                const g = Math.floor(128 + t * 127);
                const b = Math.floor(t * 255);
                return `rgb(${r}, ${g}, ${b})`;
            }
        }

        // Get color based on tws value
        function getTwsColor(tws) {
            if (!twsRange || twsRange.min === twsRange.max) {
                return 'black';
            }

            // Normalize tws to 0-1 range
            const normalized = (tws - twsRange.min) / (twsRange.max - twsRange.min);
            return getColorFromValue(normalized);
        }

        // Animation functions
        function startAnimation() {
            if (animationInterval) return;

            document.getElementById('play-btn').disabled = true;
            document.getElementById('pause-btn').disabled = false;

            const baseDelay = 50; // Base delay in milliseconds
            const delay = baseDelay / speed;

            animationInterval = setInterval(() => {
                if (currentIndex >= allPoints.length) {
                    stopAnimation();
                    return;
                }

                const point = allPoints[currentIndex];

                // Update boat marker position
                boatMarker.setLatLng([point.lat, point.lon]);

                // Update animation trail
                const trailCoords = allPoints.slice(0, currentIndex + 1).map(p => [p.lat, p.lon]);
                animationPolyline.setLatLngs(trailCoords);

                // Update info
                const progress = ((currentIndex / allPoints.length) * 100).toFixed(1);
                document.getElementById('progress-info').textContent =
                    `Time: ${point.utc} | RPM: ${point.rpm} | TWS: ${point.tws.toFixed(1)} | Progress: ${progress}%`;

                currentIndex++;
            }, delay);
        }

        function pauseAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
                document.getElementById('play-btn').disabled = false;
                document.getElementById('pause-btn').disabled = true;
            }
        }

        function stopAnimation() {
            pauseAnimation();
            document.getElementById('progress-info').textContent = 'Animation complete!';
        }

        function resetAnimation() {
            pauseAnimation();
            currentIndex = 0;

            if (allPoints.length > 0) {
                boatMarker.setLatLng([allPoints[0].lat, allPoints[0].lon]);
            }

            animationPolyline.setLatLngs([]);
            document.getElementById('progress-info').textContent = 'Ready to play';
            document.getElementById('play-btn').disabled = false;
        }

        // Event listeners
        document.getElementById('play-btn').addEventListener('click', startAnimation);
        document.getElementById('pause-btn').addEventListener('click', pauseAnimation);
        document.getElementById('reset-btn').addEventListener('click', resetAnimation);

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            document.getElementById('speed-value').textContent = `${speed}x`;

            // Restart animation with new speed if currently playing
            if (animationInterval) {
                pauseAnimation();
                startAnimation();
            }
        });

        // Initialize on page load
        window.addEventListener('load', initMap);
    </script>
</body>
</html>
