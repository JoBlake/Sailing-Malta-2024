<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sailing Track Visualizer</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        #map {
            flex: 1;
        }

        .right-sidebar {
            width: 280px;
            background: white;
            border-left: 2px solid #ddd;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .controls {
            background: white;
            padding: 15px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #speed-slider {
            width: 150px;
        }

        .info {
            font-size: 12px;
            color: #333;
            flex: 1;
            min-width: 200px;
        }

        .wind-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wind-arrow svg {
            display: block;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .legend {
            font-size: 12px;
            line-height: 1.5;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
        }

        .data-panel {
            font-size: 11px;
        }

        .data-panel-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 2px solid #28a745;
            padding-bottom: 5px;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }

        .data-label {
            font-weight: 600;
            color: #555;
        }

        .data-value {
            color: #000;
            font-family: monospace;
        }

        .legend-scale {
            display: flex;
            height: 20px;
            margin: 5px 0;
            border: 1px solid #ccc;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .legend-note {
            margin-top: 5px;
            font-size: 10px;
            font-style: italic;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading tracks...</div>

    <div class="main-content">
        <div id="map"></div>

        <div class="right-sidebar">
            <div class="legend">
                <div class="legend-title">Legend</div>
                <div style="margin-top: 5px;">
                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #555;">Arrows:</div>
                    <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 8px;">
                        <input type="checkbox" id="toggle-wind" checked style="cursor: pointer;">
                        <svg width="30" height="16" xmlns="http://www.w3.org/2000/svg">
                            <line x1="3" y1="8" x2="20" y2="8" stroke="blue" stroke-width="3"/>
                            <path d="M 20,8 L 15,5 L 17,8 L 15,11 Z" fill="blue"/>
                        </svg>
                        <span style="font-size: 11px;">True Wind (TWA/TWS)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 8px;">
                        <input type="checkbox" id="toggle-cog" checked style="cursor: pointer;">
                        <svg width="30" height="16" xmlns="http://www.w3.org/2000/svg">
                            <line x1="3" y1="8" x2="20" y2="8" stroke="green" stroke-width="3"/>
                            <path d="M 20,8 L 15,5 L 17,8 L 15,11 Z" fill="green"/>
                        </svg>
                        <span style="font-size: 11px;">Boat (COG/SOG)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 15px;">
                        <input type="checkbox" id="toggle-awa" checked style="cursor: pointer;">
                        <svg width="30" height="16" xmlns="http://www.w3.org/2000/svg">
                            <line x1="3" y1="8" x2="20" y2="8" stroke="orange" stroke-width="3"/>
                            <path d="M 20,8 L 15,5 L 17,8 L 15,11 Z" fill="orange"/>
                        </svg>
                        <span style="font-size: 11px;">Apparent Wind (AWA/AWS)</span>
                    </div>

                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #555;">Track Lines:</div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                        <svg width="40" height="16" xmlns="http://www.w3.org/2000/svg">
                            <line x1="3" y1="8" x2="37" y2="8" stroke="#007bff" stroke-width="3"/>
                        </svg>
                        <span style="font-size: 11px;">Sailing (RPM=0)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <svg width="40" height="16" xmlns="http://www.w3.org/2000/svg">
                            <line x1="3" y1="8" x2="37" y2="8" stroke="#007bff" stroke-width="3" stroke-dasharray="5,5"/>
                        </svg>
                        <span style="font-size: 11px;">Motoring (RPM>0)</span>
                    </div>
                </div>
            </div>

            <div class="data-panel">
                <div class="data-panel-title">Current Data</div>
                <div id="data-display">
                    <div class="data-row"><span class="data-label">Time:</span><span class="data-value" id="data-time">--</span></div>
                    <div class="data-row"><span class="data-label">Latitude:</span><span class="data-value" id="data-lat">--</span></div>
                    <div class="data-row"><span class="data-label">Longitude:</span><span class="data-value" id="data-lon">--</span></div>
                    <div class="data-row"><span class="data-label">RPM:</span><span class="data-value" id="data-rpm">--</span></div>
                    <div class="data-row"><span class="data-label">COG:</span><span class="data-value" id="data-cog">--</span></div>
                    <div class="data-row"><span class="data-label">SOG:</span><span class="data-value" id="data-sog">--</span></div>
                    <div class="data-row"><span class="data-label">TWA:</span><span class="data-value" id="data-twa">--</span></div>
                    <div class="data-row"><span class="data-label">TWS:</span><span class="data-value" id="data-tws">--</span></div>
                    <div class="data-row"><span class="data-label">AWA:</span><span class="data-value" id="data-awa">--</span></div>
                    <div class="data-row"><span class="data-label">AWS:</span><span class="data-value" id="data-aws">--</span></div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button id="play-btn">Play</button>
        <button id="pause-btn" disabled>Pause</button>
        <button id="reset-btn">Reset</button>
        <button id="reverse-btn">Reverse</button>
        <button id="pan-btn">Pan</button>

        <div class="speed-control">
            <label for="speed-slider">Speed:</label>
            <input type="range" id="speed-slider" min="1" max="7" value="4" step="1" />
            <span id="speed-value">1x</span>
        </div>

        <div class="info">
            <span id="progress-info">Ready to play</span>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        let map;
        let tracks = [];
        let bounds = null;
        let twsRange = null;
        let allPoints = [];
        let currentIndex = 0;
        let animationInterval = null;
        let windMarker = null;
        let cogMarker = null;
        let awaMarker = null;
        let trackPolylines = [];
        let speed = 1;
        let panEnabled = false;
        let direction = 1; // 1 for forward, -1 for reverse
        let showWindArrow = true;
        let showCogArrow = true;
        let showAwaArrow = true;

        // Map slider values (1-7) to speed multipliers
        function getSpeedMultiplier(sliderValue) {
            const speedMap = {
                1: 0.125,  // 1/8x
                2: 0.25,   // 1/4x
                3: 0.5,    // 1/2x
                4: 1,      // 1x
                5: 2,      // 2x
                6: 4,      // 4x
                7: 8       // 8x
            };
            return speedMap[sliderValue] || 1;
        }

        // Get display label for speed
        function getSpeedLabel(sliderValue) {
            const labelMap = {
                1: '1/8x',
                2: '1/4x',
                3: '1/2x',
                4: '1x',
                5: '2x',
                6: '4x',
                7: '8x'
            };
            return labelMap[sliderValue] || '1x';
        }

        // Create wind arrow icon
        // tws: True Wind Speed
        // twa: True Wind Angle (degrees) - relative to boat heading
        // cog: Course Over Ground (degrees) - boat's heading/direction
        // twsRange: {min, max} for normalization
        function createArrowIcon(tws, twa, cog, twsRange) {
            // Calculate arrow length based on TWS with truly proportional scaling
            // Use unified scale: 0-20 knots for consistency across all arrows
            const minLength = 10; // Small minimum for visibility
            const maxLength = 80;
            const maxScale = 20; // Maximum knots for scaling
            const normalized = Math.min(tws / maxScale, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Calculate absolute wind direction (COG + TWA)
            const absoluteWindDirection = cog + twa;

            // Create SVG arrow pointing towards where the wind is coming from
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${absoluteWindDirection})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="blue" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="blue" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'wind-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Create COG arrow icon (Course Over Ground)
        // cog: Course Over Ground (degrees)
        // sog: Speed Over Ground (knots)
        function createCOGArrowIcon(sog, cog) {
            // Calculate arrow length based on SOG with truly proportional scaling
            // Use unified scale: 0-20 knots for consistency across all arrows
            const minLength = 10; // Small minimum for visibility
            const maxLength = 80;
            const maxScale = 20; // Maximum knots for scaling
            const normalized = Math.min(sog / maxScale, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Create SVG arrow pointing upward (will be rotated by COG)
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${cog})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="green" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="green" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'cog-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Create AWA arrow icon (Apparent Wind Angle)
        // aws: Apparent Wind Speed (knots)
        // awa: Apparent Wind Angle (degrees) - relative to boat heading
        // cog: Course Over Ground (degrees) - boat's heading/direction
        function createAWAArrowIcon(aws, awa, cog) {
            // Calculate arrow length based on AWS with truly proportional scaling
            // Use unified scale: 0-20 knots for consistency across all arrows
            const minLength = 10; // Small minimum for visibility
            const maxLength = 80;
            const maxScale = 20; // Maximum knots for scaling
            const normalized = Math.min(aws / maxScale, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Calculate absolute apparent wind direction (COG + AWA)
            const absoluteApparentWindDirection = cog + awa;

            // Create SVG arrow pointing towards where the apparent wind is coming from
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${absoluteApparentWindDirection})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="orange" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="orange" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'awa-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Initialize the map
        async function initMap() {
            try {
                // Fetch track data
                const response = await fetch('/api/tracks');
                const data = await response.json();
                tracks = data.tracks;
                bounds = data.bounds;
                twsRange = data.tws_range;

                // Hide loading indicator
                document.getElementById('loading').style.display = 'none';

                // Create map centered on the tracks
                if (bounds) {
                    map = L.map('map').setView(
                        [bounds.center_lat, bounds.center_lon],
                        13
                    );
                } else {
                    map = L.map('map').setView([38.92, 20.89], 13);
                }

                // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                // Draw all tracks on the map with line style based on RPM
                tracks.forEach((track, index) => {
                    // Draw segments: solid when rpm=0 (sailing), dotted when rpm>0 (motoring)
                    for (let i = 0; i < track.points.length - 1; i++) {
                        const p1 = track.points[i];
                        const p2 = track.points[i + 1];

                        // Determine line style based on RPM
                        let dashArray;
                        if (p1.rpm === 0 && p2.rpm === 0) {
                            dashArray = null; // Solid line for sailing
                        } else {
                            dashArray = '5, 10'; // Dotted line for motoring
                        }

                        const segment = L.polyline(
                            [[p1.lat, p1.lon], [p2.lat, p2.lon]],
                            {
                                color: 'blue',
                                weight: 3,
                                opacity: 0.7,
                                dashArray: dashArray
                            }
                        ).addTo(map);
                        trackPolylines.push(segment);
                    }

                    // Add start marker
                    if (track.points.length > 0) {
                        const start = track.points[0];
                        L.circleMarker([start.lat, start.lon], {
                            radius: 5,
                            color: 'green',
                            fillColor: 'green',
                            fillOpacity: 1
                        }).addTo(map).bindPopup(`Start: ${track.name}`);
                    }

                    // Add end marker
                    if (track.points.length > 0) {
                        const end = track.points[track.points.length - 1];
                        L.circleMarker([end.lat, end.lon], {
                            radius: 5,
                            color: 'red',
                            fillColor: 'red',
                            fillOpacity: 1
                        }).addTo(map).bindPopup(`End: ${track.name}`);
                    }

                    // Collect all points for animation
                    track.points.forEach(point => {
                        allPoints.push({
                            ...point,
                            trackName: track.name
                        });
                    });
                });

                // Sort all points chronologically by UTC timestamp
                allPoints.sort((a, b) => {
                    return new Date(a.utc) - new Date(b.utc);
                });

                // Fit map to bounds
                if (bounds) {
                    map.fitBounds([
                        [bounds.min_lat, bounds.min_lon],
                        [bounds.max_lat, bounds.max_lon]
                    ]);
                }

                // Add event listeners for arrow toggles
                document.getElementById('toggle-wind').addEventListener('change', (e) => {
                    showWindArrow = e.target.checked;
                    if (showWindArrow) {
                        windMarker.addTo(map);
                    } else {
                        map.removeLayer(windMarker);
                    }
                });

                document.getElementById('toggle-cog').addEventListener('change', (e) => {
                    showCogArrow = e.target.checked;
                    if (showCogArrow) {
                        cogMarker.addTo(map);
                    } else {
                        map.removeLayer(cogMarker);
                    }
                });

                document.getElementById('toggle-awa').addEventListener('change', (e) => {
                    showAwaArrow = e.target.checked;
                    if (showAwaArrow) {
                        awaMarker.addTo(map);
                    } else {
                        map.removeLayer(awaMarker);
                    }
                });

                // Create wind arrow marker (blue)
                if (allPoints.length > 0) {
                    const firstPoint = allPoints[0];
                    const windArrowIcon = createArrowIcon(firstPoint.tws, firstPoint.twa, firstPoint.cog, twsRange);
                    windMarker = L.marker(
                        [firstPoint.lat, firstPoint.lon],
                        { icon: windArrowIcon }
                    ).addTo(map);

                    // Create COG arrow marker (green)
                    const cogArrowIcon = createCOGArrowIcon(firstPoint.sog, firstPoint.cog);
                    cogMarker = L.marker(
                        [firstPoint.lat, firstPoint.lon],
                        { icon: cogArrowIcon }
                    ).addTo(map);

                    // Create AWA arrow marker (orange)
                    const awaArrowIcon = createAWAArrowIcon(firstPoint.aws, firstPoint.awa, firstPoint.cog);
                    awaMarker = L.marker(
                        [firstPoint.lat, firstPoint.lon],
                        { icon: awaArrowIcon }
                    ).addTo(map);

                    // Initialize data panel with first point
                    document.getElementById('data-time').textContent = firstPoint.utc;
                    document.getElementById('data-lat').textContent = firstPoint.lat.toFixed(6) + '°';
                    document.getElementById('data-lon').textContent = firstPoint.lon.toFixed(6) + '°';
                    document.getElementById('data-rpm').textContent = firstPoint.rpm;
                    document.getElementById('data-cog').textContent = firstPoint.cog.toFixed(1) + '°';
                    document.getElementById('data-sog').textContent = firstPoint.sog.toFixed(2) + ' kt';
                    document.getElementById('data-twa').textContent = firstPoint.twa.toFixed(1) + '°';
                    document.getElementById('data-tws').textContent = firstPoint.tws.toFixed(1) + ' kt';
                    document.getElementById('data-awa').textContent = firstPoint.awa.toFixed(1) + '°';
                    document.getElementById('data-aws').textContent = firstPoint.aws.toFixed(2) + ' kt';
                }

                // No animation polyline - boat marker only to preserve original track visibility

            } catch (error) {
                console.error('Error loading tracks:', error);
                document.getElementById('loading').textContent = 'Error loading tracks!';
            }
        }

        // CMRmap colormap (Color Map for Remote sensing)
        // Maps a value from 0-1 to a color: Black -> Red -> Magenta -> Blue -> White
        function getColorFromValue(value) {
            // Clamp value between 0 and 1
            value = Math.max(0, Math.min(1, value));

            // CMRmap: Black -> Red -> Magenta -> Blue -> White
            if (value < 0.25) {
                // Black to Red
                const t = value / 0.25;
                const r = Math.floor(t * 255);
                const g = 0;
                const b = 0;
                return `rgb(${r}, ${g}, ${b})`;
            } else if (value < 0.5) {
                // Red to Magenta
                const t = (value - 0.25) / 0.25;
                const r = 255;
                const g = 0;
                const b = Math.floor(t * 255);
                return `rgb(${r}, ${g}, ${b})`;
            } else if (value < 0.75) {
                // Magenta to Blue
                const t = (value - 0.5) / 0.25;
                const r = Math.floor(255 * (1 - t));
                const g = 0;
                const b = 255;
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // Blue to White
                const t = (value - 0.75) / 0.25;
                const r = Math.floor(t * 255);
                const g = Math.floor(t * 255);
                const b = 255;
                return `rgb(${r}, ${g}, ${b})`;
            }
        }

        // Get color based on tws value
        function getTwsColor(tws) {
            if (!twsRange || twsRange.min === twsRange.max) {
                return 'black';
            }

            // Normalize tws to 0-1 range
            const normalized = (tws - twsRange.min) / (twsRange.max - twsRange.min);
            return getColorFromValue(normalized);
        }

        // Animation functions
        function startAnimation() {
            if (animationInterval) return;

            document.getElementById('play-btn').disabled = true;
            document.getElementById('pause-btn').disabled = false;

            const baseDelay = 50; // Base delay in milliseconds
            const delay = baseDelay / speed;

            animationInterval = setInterval(() => {
                // Check bounds based on direction
                if (direction === 1 && currentIndex >= allPoints.length) {
                    stopAnimation();
                    return;
                }
                if (direction === -1 && currentIndex < 0) {
                    stopAnimation();
                    return;
                }

                const point = allPoints[currentIndex];

                // Update wind arrow position and icon (blue)
                windMarker.setLatLng([point.lat, point.lon]);
                const newWindArrowIcon = createArrowIcon(point.tws, point.twa, point.cog, twsRange);
                windMarker.setIcon(newWindArrowIcon);

                // Update COG arrow position and icon (green)
                cogMarker.setLatLng([point.lat, point.lon]);
                const newCOGArrowIcon = createCOGArrowIcon(point.sog, point.cog);
                cogMarker.setIcon(newCOGArrowIcon);

                // Update AWA arrow position and icon (orange)
                awaMarker.setLatLng([point.lat, point.lon]);
                const newAWAArrowIcon = createAWAArrowIcon(point.aws, point.awa, point.cog);
                awaMarker.setIcon(newAWAArrowIcon);

                // Pan map to center on current position if enabled
                if (panEnabled) {
                    map.panTo([point.lat, point.lon]);
                }

                // Update info in bottom bar and right sidebar
                document.getElementById('progress-info').textContent =
                    `Point ${currentIndex + 1} of ${allPoints.length} (${((currentIndex / allPoints.length) * 100).toFixed(1)}%)`;

                // Update data panel in sidebar
                document.getElementById('data-time').textContent = point.utc;
                document.getElementById('data-lat').textContent = point.lat.toFixed(6) + '°';
                document.getElementById('data-lon').textContent = point.lon.toFixed(6) + '°';
                document.getElementById('data-rpm').textContent = point.rpm;
                document.getElementById('data-cog').textContent = point.cog.toFixed(1) + '°';
                document.getElementById('data-sog').textContent = point.sog.toFixed(2) + ' kt';
                document.getElementById('data-twa').textContent = point.twa.toFixed(1) + '°';
                document.getElementById('data-tws').textContent = point.tws.toFixed(1) + ' kt';
                document.getElementById('data-awa').textContent = point.awa.toFixed(1) + '°';
                document.getElementById('data-aws').textContent = point.aws.toFixed(2) + ' kt';

                currentIndex += direction;
            }, delay);
        }

        function pauseAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
                document.getElementById('play-btn').disabled = false;
                document.getElementById('pause-btn').disabled = true;
            }
        }

        function stopAnimation() {
            pauseAnimation();
            document.getElementById('progress-info').textContent = 'Animation complete!';
        }

        function resetAnimation() {
            pauseAnimation();
            currentIndex = 0;
            direction = 1;

            // Reset Reverse button appearance
            const reverseBtn = document.getElementById('reverse-btn');
            reverseBtn.style.background = '#007bff';
            reverseBtn.textContent = 'Reverse';

            if (allPoints.length > 0) {
                windMarker.setLatLng([allPoints[0].lat, allPoints[0].lon]);
                cogMarker.setLatLng([allPoints[0].lat, allPoints[0].lon]);
                awaMarker.setLatLng([allPoints[0].lat, allPoints[0].lon]);
            }

            document.getElementById('progress-info').textContent = 'Ready to play';
            document.getElementById('play-btn').disabled = false;
        }

        // Event listeners
        document.getElementById('play-btn').addEventListener('click', startAnimation);
        document.getElementById('pause-btn').addEventListener('click', pauseAnimation);
        document.getElementById('reset-btn').addEventListener('click', resetAnimation);

        document.getElementById('pan-btn').addEventListener('click', () => {
            panEnabled = !panEnabled;
            const btn = document.getElementById('pan-btn');
            if (panEnabled) {
                btn.style.background = '#28a745';
                btn.textContent = 'Pan: ON';
            } else {
                btn.style.background = '#007bff';
                btn.textContent = 'Pan';
            }
        });

        document.getElementById('reverse-btn').addEventListener('click', () => {
            direction = -direction;
            const btn = document.getElementById('reverse-btn');
            if (direction === -1) {
                btn.style.background = '#ffc107';
                btn.textContent = 'Reverse: ON';
            } else {
                btn.style.background = '#007bff';
                btn.textContent = 'Reverse';
            }

            // Restart animation with new direction if currently playing
            if (animationInterval) {
                pauseAnimation();
                startAnimation();
            }
        });

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);
            speed = getSpeedMultiplier(sliderValue);
            document.getElementById('speed-value').textContent = getSpeedLabel(sliderValue);

            // Restart animation with new speed if currently playing
            if (animationInterval) {
                pauseAnimation();
                startAnimation();
            }
        });

        // Initialize on page load
        window.addEventListener('load', initMap);
    </script>
</body>
</html>
