<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sailing Track Visualizer</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        #map {
            flex: 1;
        }

        .right-sidebar {
            width: 280px;
            min-width: 200px;
            max-width: 600px;
            background: white;
            border-left: 2px solid #ddd;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .resize-handle {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
            background: transparent;
            z-index: 1000;
            transition: background 0.2s;
        }

        .resize-handle:hover {
            background: rgba(0, 123, 255, 0.3);
        }

        .resize-handle:active {
            background: rgba(0, 123, 255, 0.5);
        }

        .tabs {
            display: flex;
            background: #f5f5f5;
            border-bottom: 2px solid #ddd;
        }

        .tab-button {
            flex: 1;
            padding: 12px;
            background: #f5f5f5;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }

        .tab-button:hover {
            background: #e0e0e0;
            color: #333;
        }

        .tab-button.active {
            background: white;
            color: #007bff;
            border-bottom-color: #007bff;
        }

        .tab-content {
            display: none;
            padding: 15px;
            flex: 1;
            overflow-y: auto;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .controls {
            background: white;
            padding: 15px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #speed-slider {
            width: 150px;
        }

        .info {
            font-size: 12px;
            color: #333;
            flex: 1;
            min-width: 200px;
        }

        .wind-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wind-arrow svg {
            display: block;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 500px;
        }

        .prompt-dialog {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 600px;
            margin: 0 auto;
        }

        .prompt-dialog h2 {
            margin-top: 0;
            color: #007bff;
            font-size: 24px;
        }

        .prompt-dialog p {
            color: #666;
            margin: 15px 0;
            line-height: 1.6;
        }

        .prompt-dialog input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin: 10px 0;
            box-sizing: border-box;
        }

        .prompt-dialog input:focus {
            border-color: #007bff;
            outline: none;
        }

        .prompt-dialog button {
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
        }

        .prompt-dialog button:hover {
            background: #0056b3;
        }

        .prompt-dialog .example {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            margin: 10px 0;
            border-left: 3px solid #007bff;
        }

        .legend {
            font-size: 12px;
            line-height: 1.5;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
        }

        .data-panel {
            font-size: 11px;
        }

        .data-panel-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 2px solid #28a745;
            padding-bottom: 5px;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }

        .data-label {
            font-weight: 600;
            color: #555;
        }

        .data-value {
            color: #000;
            font-family: monospace;
        }

        .legend-scale {
            display: flex;
            height: 20px;
            margin: 5px 0;
            border: 1px solid #ccc;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .legend-note {
            margin-top: 5px;
            font-size: 10px;
            font-style: italic;
            color: #666;
        }

        .boat-marker {
            font-size: 32px;
            text-align: center;
            filter: drop-shadow(3px 3px 3px rgba(0,0,0,0.4));
            cursor: pointer;
        }

        .photo-marker {
            font-size: 24px;
            text-align: center;
            cursor: pointer;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));
        }

        .photo-marker:hover {
            transform: scale(1.2);
        }

        .photo-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            right: 280px; /* Leave space for right sidebar */
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            overflow: auto;
        }

        .photo-modal-content {
            margin: auto;
            display: block;
            max-width: 90%;
            max-height: 90%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .photo-modal-close {
            position: absolute;
            top: 20px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 2001;
        }

        .photo-modal-close:hover,
        .photo-modal-close:focus {
            color: #bbb;
        }

        .photo-modal-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
        }

        .annotation-marker {
            font-size: 24px;
            text-align: center;
            cursor: pointer;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));
        }

        .annotation-marker:hover {
            transform: scale(1.2);
        }

        .annotation-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .annotation-form textarea {
            width: 100%;
            min-height: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            font-family: Arial, sans-serif;
            resize: vertical;
        }

        .annotation-form button {
            padding: 8px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .annotation-form button:hover {
            background: #218838;
        }

        .annotation-list {
            max-height: 300px;
            overflow-y: auto;
            font-size: 11px;
        }

        .annotation-item {
            padding: 8px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-left: 3px solid #007bff;
            cursor: pointer;
        }

        .annotation-item:hover {
            background: #e9ecef;
        }

        .annotation-item-time {
            font-size: 10px;
            color: #666;
            margin-bottom: 4px;
        }

        .annotation-item-text {
            color: #333;
        }

        .distance-display {
            background: #e7f3ff;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .distance-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }

        .distance-label {
            font-weight: 600;
            color: #555;
            font-size: 11px;
        }

        .distance-value {
            color: #007bff;
            font-family: monospace;
            font-weight: bold;
            font-size: 11px;
        }

        /* Mobile Responsive Styles */
        @media screen and (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .right-sidebar {
                width: 100% !important;
                max-height: 40vh;
                border-left: none;
                border-top: 2px solid #ddd;
            }

            .resize-handle {
                display: none;
            }

            #map {
                height: 60vh;
            }

            .controls {
                font-size: 12px;
                padding: 10px;
            }

            button {
                padding: 8px 12px;
                font-size: 12px;
            }

            .speed-control {
                width: 100%;
            }

            #speed-slider {
                width: 100px;
            }

            .info {
                min-width: 100%;
                margin-top: 5px;
            }

            .photo-modal {
                right: 0;
            }

            .tab-button {
                font-size: 11px;
                padding: 10px 5px;
            }
        }

        @media screen and (max-width: 480px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .speed-control {
                justify-content: space-between;
            }

            button {
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading tracks...</div>

    <!-- Photo Modal -->
    <div id="photo-modal" class="photo-modal">
        <span class="photo-modal-close" onclick="closePhotoModal()">&times;</span>
        <img class="photo-modal-content" id="modal-image">
        <div class="photo-modal-info" id="modal-info"></div>
    </div>

    <div class="main-content">
        <div id="map"></div>

        <div class="right-sidebar" id="right-sidebar">
            <!-- Resize handle -->
            <div class="resize-handle" id="resize-handle"></div>

            <!-- Tab buttons -->
            <div class="tabs">
                <button class="tab-button active" onclick="switchTab('home')">Home</button>
                <button class="tab-button" onclick="switchTab('photo')">Photo</button>
                <button class="tab-button" onclick="switchTab('annotation')">Annotation</button>
            </div>

            <!-- Home Tab -->
            <div id="home-tab" class="tab-content active">
                <div class="data-panel">
                    <div class="data-panel-title">Track Directory</div>
                    <div style="font-size: 11px;">
                        <input type="text" id="track-directory" placeholder="Enter directory path (e.g., . or /path/to/tracks)"
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px; margin-bottom: 8px;">
                        <button onclick="updateTrackDirectory()" style="width: 100%; padding: 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            Load Tracks from Directory
                        </button>
                        <div id="directory-status" style="font-size: 10px; color: #666; margin-top: 5px; text-align: center;">Current: .</div>
                    </div>
                </div>

                <div class="legend">
                    <div class="legend-title">Legend</div>
                    <div style="margin-top: 5px;">
                        <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #555;">Arrows:</div>
                        <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 8px;">
                            <input type="checkbox" id="toggle-wind" checked style="cursor: pointer;">
                            <svg width="30" height="16" xmlns="http://www.w3.org/2000/svg">
                                <line x1="3" y1="8" x2="20" y2="8" stroke="blue" stroke-width="3"/>
                                <path d="M 20,8 L 15,5 L 17,8 L 15,11 Z" fill="blue"/>
                            </svg>
                            <span style="font-size: 11px;">True Wind (TWA/TWS)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 8px;">
                            <input type="checkbox" id="toggle-cog" checked style="cursor: pointer;">
                            <svg width="30" height="16" xmlns="http://www.w3.org/2000/svg">
                                <line x1="3" y1="8" x2="20" y2="8" stroke="green" stroke-width="3"/>
                                <path d="M 20,8 L 15,5 L 17,8 L 15,11 Z" fill="green"/>
                            </svg>
                            <span style="font-size: 11px;">Boat (COG/SOG)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 15px;">
                            <input type="checkbox" id="toggle-awa" checked style="cursor: pointer;">
                            <svg width="30" height="16" xmlns="http://www.w3.org/2000/svg">
                                <line x1="3" y1="8" x2="20" y2="8" stroke="orange" stroke-width="3"/>
                                <path d="M 20,8 L 15,5 L 17,8 L 15,11 Z" fill="orange"/>
                            </svg>
                            <span style="font-size: 11px;">Apparent Wind (AWA/AWS)</span>
                        </div>

                        <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #555;">Track Lines:</div>
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                            <svg width="40" height="16" xmlns="http://www.w3.org/2000/svg">
                                <line x1="3" y1="8" x2="37" y2="8" stroke="blue" stroke-width="3"/>
                            </svg>
                            <span style="font-size: 11px;">Sailing (RPM=0)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                            <svg width="40" height="16" xmlns="http://www.w3.org/2000/svg">
                                <line x1="3" y1="8" x2="37" y2="8" stroke="red" stroke-width="3"/>
                            </svg>
                            <span style="font-size: 11px;">Motoring (RPM>0)</span>
                        </div>
                    </div>
                </div>

                <div class="distance-display">
                    <div style="font-weight: bold; margin-bottom: 8px; font-size: 12px; color: #007bff;">Distance Travelled</div>
                    <div class="distance-row">
                        <span class="distance-label">Nautical Miles:</span>
                        <span class="distance-value" id="distance-nm">0.00 nm</span>
                    </div>
                    <div class="distance-row">
                        <span class="distance-label">Kilometers:</span>
                        <span class="distance-value" id="distance-km">0.00 km</span>
                    </div>
                </div>

                <div class="data-panel">
                    <div class="data-panel-title">Current Data</div>
                    <div id="data-display">
                        <div class="data-row"><span class="data-label">Time:</span><span class="data-value" id="data-time">--</span></div>
                        <div class="data-row"><span class="data-label">Latitude:</span><span class="data-value" id="data-lat">--</span></div>
                        <div class="data-row"><span class="data-label">Longitude:</span><span class="data-value" id="data-lon">--</span></div>
                        <div class="data-row"><span class="data-label">RPM:</span><span class="data-value" id="data-rpm">--</span></div>
                        <div class="data-row"><span class="data-label">COG:</span><span class="data-value" id="data-cog">--</span></div>
                        <div class="data-row"><span class="data-label">SOG:</span><span class="data-value" id="data-sog">--</span></div>
                        <div class="data-row"><span class="data-label">TWA:</span><span class="data-value" id="data-twa">--</span></div>
                        <div class="data-row"><span class="data-label">TWS:</span><span class="data-value" id="data-tws">--</span></div>
                        <div class="data-row"><span class="data-label">AWA:</span><span class="data-value" id="data-awa">--</span></div>
                        <div class="data-row"><span class="data-label">AWS:</span><span class="data-value" id="data-aws">--</span></div>
                    </div>
                </div>

                <div class="data-panel">
                    <div class="data-panel-title">Position Control</div>
                    <div style="font-size: 11px; padding: 5px 0;">
                        <label for="position-slider" style="display: block; margin-bottom: 5px; font-weight: 600; color: #555;">Track Position:</label>
                        <input type="range" id="position-slider" min="0" max="100" value="0" style="width: 100%; cursor: pointer;">
                        <div id="position-info" style="font-size: 10px; color: #666; margin-top: 5px; text-align: center;">Point 0 of 0</div>
                    </div>
                </div>
            </div>

            <!-- Photo Tab -->
            <div id="photo-tab" class="tab-content">
                <div class="photo-panel">
                    <div class="data-panel-title">Photo Gallery</div>
                    <div style="font-size: 11px;">
                        <label for="photo-upload" style="display: block; margin-bottom: 8px; cursor: pointer; padding: 8px; background: #007bff; color: white; text-align: center; border-radius: 4px;">
                            Select Photos
                            <input type="file" id="photo-upload" multiple accept="image/*" style="display: none;">
                        </label>
                        <div id="photo-status" style="font-size: 10px; color: #666; margin-top: 5px;">No photos loaded</div>
                        <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 10px; color: #666;">
                            <strong>Instructions:</strong> Select photos with GPS metadata. They will appear as camera icons on the map at their GPS coordinates. Click on the icons to view full-size photos.
                        </div>
                    </div>
                </div>
            </div>

            <!-- Annotation Tab -->
            <div id="annotation-tab" class="tab-content">
                <div class="annotation-panel">
                    <div class="data-panel-title">Add Annotation</div>
                    <div class="annotation-form">
                        <textarea id="annotation-text" placeholder="Enter annotation text for current position..."></textarea>
                        <button onclick="addAnnotation()">Add Annotation</button>
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 10px; color: #666;">
                        <strong>Note:</strong> Annotations are added at the current track position. Use the position slider in the Home tab to select where to add an annotation.
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <div class="data-panel-title">Manage Annotations</div>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button onclick="saveAnnotations()" style="flex: 1; padding: 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            Save to Track Directory
                        </button>
                        <label for="annotation-file-input" style="flex: 1; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; text-align: center;">
                            Load from File
                            <input type="file" id="annotation-file-input" accept=".json" style="display: none;" onchange="loadAnnotations(event)">
                        </label>
                    </div>
                    <div style="font-size: 10px; color: #666; margin-top: 5px;">
                        Annotations are saved as <code style="background: #e9ecef; padding: 2px 4px; border-radius: 2px;">sailing-annotations.json</code> in your track directory and auto-load on startup.
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <div class="data-panel-title">Annotations List</div>
                    <div id="annotations-list" class="annotation-list">
                        <div style="font-size: 11px; color: #999; text-align: center; padding: 20px;">No annotations yet</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button id="play-btn">Play</button>
        <button id="pause-btn" disabled>Pause</button>
        <button id="reset-btn">Reset</button>
        <button id="reverse-btn">Reverse</button>
        <button id="pan-btn">Pan</button>

        <div class="speed-control">
            <label for="speed-slider">Speed:</label>
            <input type="range" id="speed-slider" min="1" max="7" value="4" step="1" />
            <span id="speed-value">1x</span>
        </div>

        <div class="info">
            <span id="progress-info">Ready to play</span>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- EXIF.js for reading GPS data from photos -->
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>

    <script>
        let map;
        let tracks = [];
        let bounds = null;
        let allPoints = [];
        let currentIndex = 0;
        let animationInterval = null;
        let windMarker = null;
        let cogMarker = null;
        let awaMarker = null;
        let boatMarker = null; // Simple boat position marker for GPX files
        let trackPolylines = [];
        let speed = 1;
        let panEnabled = false;
        let direction = 1; // 1 for forward, -1 for reverse
        let showWindArrow = true;
        let showCogArrow = true;
        let showAwaArrow = true;
        let photoMarkers = [];
        let annotations = [];
        let annotationMarkers = [];
        let totalDistanceNM = 0;
        let totalDistanceKM = 0;
        let hasSailingData = false; // Flag to track if any loaded track has sailing data

        // Tab switching function
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
        }

        // Helper function to calculate distance between two lat/lon points (Haversine formula)
        // Returns distance in nautical miles
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3440.065; // Earth's radius in nautical miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Calculate distance from start to current position
        function calculateDistanceToCurrentPosition() {
            let distanceNM = 0;
            // Calculate distance from start (index 0) to current position
            for (let i = 1; i <= currentIndex && i < allPoints.length; i++) {
                const p1 = allPoints[i - 1];
                const p2 = allPoints[i];
                distanceNM += calculateDistance(p1.lat, p1.lon, p2.lat, p2.lon);
            }
            totalDistanceNM = distanceNM;
            totalDistanceKM = distanceNM * 1.852; // Convert to kilometers
            updateDistanceDisplay();
        }

        // Update distance display
        function updateDistanceDisplay() {
            document.getElementById('distance-nm').textContent = totalDistanceNM.toFixed(2) + ' nm';
            document.getElementById('distance-km').textContent = totalDistanceKM.toFixed(2) + ' km';
        }

        // Add annotation at current position
        function addAnnotation() {
            const text = document.getElementById('annotation-text').value.trim();
            if (!text) {
                alert('Please enter annotation text');
                return;
            }

            if (allPoints.length === 0 || currentIndex >= allPoints.length) {
                alert('No track position available');
                return;
            }

            const point = allPoints[currentIndex];
            const annotation = {
                text: text,
                lat: point.lat,
                lon: point.lon,
                timestamp: point.utc,
                index: currentIndex
            };

            annotations.push(annotation);

            // Add marker to map
            const annotationIcon = L.divIcon({
                html: 'üìù',
                iconSize: [24, 24],
                className: 'annotation-marker',
                iconAnchor: [12, 12]
            });

            const marker = L.marker([point.lat, point.lon], { icon: annotationIcon })
                .addTo(map)
                .on('click', function() {
                    showAnnotationPopup(annotation);
                });

            annotationMarkers.push(marker);

            // Clear textarea
            document.getElementById('annotation-text').value = '';

            // Update annotations list
            updateAnnotationsList();

            // Show success message
            alert('Annotation added successfully!');
        }

        // Show annotation popup
        function showAnnotationPopup(annotation) {
            const popup = L.popup()
                .setLatLng([annotation.lat, annotation.lon])
                .setContent(`
                    <div style="max-width: 200px;">
                        <div style="font-weight: bold; margin-bottom: 5px;">Annotation</div>
                        <div style="margin-bottom: 8px; white-space: pre-wrap;">${annotation.text}</div>
                        <div style="font-size: 10px; color: #666; border-top: 1px solid #ddd; padding-top: 5px;">
                            ${annotation.timestamp}
                        </div>
                    </div>
                `)
                .openOn(map);
        }

        // Update annotations list in UI
        function updateAnnotationsList() {
            const listContainer = document.getElementById('annotations-list');

            if (annotations.length === 0) {
                listContainer.innerHTML = '<div style="font-size: 11px; color: #999; text-align: center; padding: 20px;">No annotations yet</div>';
                return;
            }

            listContainer.innerHTML = annotations.map((annotation, index) => `
                <div class="annotation-item" onclick="jumpToAnnotation(${index})">
                    <div class="annotation-item-time">${annotation.timestamp}</div>
                    <div class="annotation-item-text">${annotation.text}</div>
                </div>
            `).join('');
        }

        // Jump to annotation position
        function jumpToAnnotation(index) {
            const annotation = annotations[index];

            // Pan map to annotation
            map.setView([annotation.lat, annotation.lon], map.getZoom());

            // Update current index and position
            currentIndex = annotation.index;

            // Update arrows and data display
            if (allPoints.length > 0 && currentIndex < allPoints.length) {
                const point = allPoints[currentIndex];

                // Update arrows (only if sailing data available)
                if (hasSailingData) {
                    windMarker.setLatLng([point.lat, point.lon]);
                    const newWindArrowIcon = createArrowIcon(point.tws || 0, point.twa || 0, point.cog || 0);
                    windMarker.setIcon(newWindArrowIcon);

                    cogMarker.setLatLng([point.lat, point.lon]);
                    const newCOGArrowIcon = createCOGArrowIcon(point.sog || 0, point.cog || 0);
                    cogMarker.setIcon(newCOGArrowIcon);

                    awaMarker.setLatLng([point.lat, point.lon]);
                    const newAWAArrowIcon = createAWAArrowIcon(point.aws || 0, point.awa || 0, point.cog || 0);
                    awaMarker.setIcon(newAWAArrowIcon);
                }

                updateDataDisplay(point);

                // Update distance from start to current position
                calculateDistanceToCurrentPosition();

                document.getElementById('position-slider').value = currentIndex;
                document.getElementById('position-info').textContent = `${point.utc} (${currentIndex + 1}/${allPoints.length})`;
            }

            // Show popup
            showAnnotationPopup(annotation);
        }

        // Save annotations to JSON file in track directory
        async function saveAnnotations() {
            if (annotations.length === 0) {
                alert('No annotations to save');
                return;
            }

            try {
                // Send annotations to server to save in track directory
                const response = await fetch('/api/annotations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ annotations: annotations })
                });

                const data = await response.json();

                if (data.status === 'success') {
                    alert(data.message);
                } else {
                    alert('Error saving annotations: ' + data.message);
                }
            } catch (error) {
                console.error('Error saving annotations:', error);
                alert('Error saving annotations: ' + error.message);
            }
        }

        // Load annotations from JSON file
        function loadAnnotations(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const loadedAnnotations = JSON.parse(e.target.result);

                    if (!Array.isArray(loadedAnnotations)) {
                        alert('Invalid annotation file format');
                        return;
                    }

                    // Clear existing annotations
                    annotationMarkers.forEach(marker => map.removeLayer(marker));
                    annotationMarkers = [];
                    annotations = [];

                    // Load new annotations
                    loadedAnnotations.forEach(annotation => {
                        // Validate annotation structure
                        if (annotation.text && annotation.lat && annotation.lon && annotation.timestamp !== undefined && annotation.index !== undefined) {
                            annotations.push(annotation);

                            // Add marker to map
                            const annotationIcon = L.divIcon({
                                html: 'üìù',
                                iconSize: [24, 24],
                                className: 'annotation-marker',
                                iconAnchor: [12, 12]
                            });

                            const marker = L.marker([annotation.lat, annotation.lon], { icon: annotationIcon })
                                .addTo(map)
                                .on('click', function() {
                                    showAnnotationPopup(annotation);
                                });

                            annotationMarkers.push(marker);
                        }
                    });

                    // Update annotations list
                    updateAnnotationsList();

                    alert(`Loaded ${annotations.length} annotation(s)`);

                    // Reset file input
                    event.target.value = '';

                } catch (error) {
                    alert('Error loading annotations: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Helper function to update data display
        function updateDataDisplay(point) {
            document.getElementById('data-time').textContent = point.utc || '--';
            document.getElementById('data-lat').textContent = point.lat ? point.lat.toFixed(6) + '¬∞' : '--';
            document.getElementById('data-lon').textContent = point.lon ? point.lon.toFixed(6) + '¬∞' : '--';

            // Check if this is estimated data (from GPX files)
            const isEstimated = point.estimated === true;

            // Show sailing data if available, or estimated values for GPX
            if (hasSailingData) {
                document.getElementById('data-rpm').textContent = point.rpm !== null ? point.rpm : '--';
                document.getElementById('data-cog').textContent = point.cog !== null ? point.cog.toFixed(1) + '¬∞' : '--';
                document.getElementById('data-sog').textContent = point.sog !== null ? point.sog.toFixed(2) + ' kt' : '--';
                document.getElementById('data-twa').textContent = point.twa !== null ? point.twa.toFixed(1) + '¬∞' : '--';
                document.getElementById('data-tws').textContent = point.tws !== null ? point.tws.toFixed(1) + ' kt' : '--';
                document.getElementById('data-awa').textContent = point.awa !== null ? point.awa.toFixed(1) + '¬∞' : '--';
                document.getElementById('data-aws').textContent = point.aws !== null ? point.aws.toFixed(2) + ' kt' : '--';
            } else if (isEstimated) {
                // For GPX files, show estimated SOG and COG
                document.getElementById('data-cog').textContent = point.cog !== null ? point.cog.toFixed(1) + '¬∞ (est.)' : '--';
                document.getElementById('data-sog').textContent = point.sog !== null ? point.sog.toFixed(2) + ' kt (est.)' : '--';
            }
        }

        // Map slider values (1-7) to speed multipliers
        function getSpeedMultiplier(sliderValue) {
            const speedMap = {
                1: 0.125,  // 1/8x
                2: 0.25,   // 1/4x
                3: 0.5,    // 1/2x
                4: 1,      // 1x
                5: 2,      // 2x
                6: 4,      // 4x
                7: 8       // 8x
            };
            return speedMap[sliderValue] || 1;
        }

        // Get display label for speed
        function getSpeedLabel(sliderValue) {
            const labelMap = {
                1: '1/8x',
                2: '1/4x',
                3: '1/2x',
                4: '1x',
                5: '2x',
                6: '4x',
                7: '8x'
            };
            return labelMap[sliderValue] || '1x';
        }

        // Create wind arrow icon
        // tws: True Wind Speed
        // twa: True Wind Angle (degrees) - relative to boat heading
        // cog: Course Over Ground (degrees) - boat's heading/direction
        function createArrowIcon(tws, twa, cog) {
            // Calculate arrow length based on TWS with truly proportional scaling
            // Use unified scale: 0-20 knots for consistency across all arrows
            const minLength = 10; // Small minimum for visibility
            const maxLength = 80;
            const maxScale = 20; // Maximum knots for scaling
            const normalized = Math.min(tws / maxScale, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Calculate absolute wind direction (COG + TWA)
            const absoluteWindDirection = cog + twa;

            // Create SVG arrow pointing towards where the wind is coming from
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${absoluteWindDirection})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="blue" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="blue" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'wind-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Create COG arrow icon (Course Over Ground)
        // cog: Course Over Ground (degrees)
        // sog: Speed Over Ground (knots)
        function createCOGArrowIcon(sog, cog) {
            // Calculate arrow length based on SOG with truly proportional scaling
            // Use unified scale: 0-20 knots for consistency across all arrows
            const minLength = 10; // Small minimum for visibility
            const maxLength = 80;
            const maxScale = 20; // Maximum knots for scaling
            const normalized = Math.min(sog / maxScale, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Create SVG arrow pointing upward (will be rotated by COG)
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${cog})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="green" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="green" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'cog-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Create AWA arrow icon (Apparent Wind Angle)
        // aws: Apparent Wind Speed (knots)
        // awa: Apparent Wind Angle (degrees) - relative to boat heading
        // cog: Course Over Ground (degrees) - boat's heading/direction
        function createAWAArrowIcon(aws, awa, cog) {
            // Calculate arrow length based on AWS with truly proportional scaling
            // Use unified scale: 0-20 knots for consistency across all arrows
            const minLength = 10; // Small minimum for visibility
            const maxLength = 80;
            const maxScale = 20; // Maximum knots for scaling
            const normalized = Math.min(aws / maxScale, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Calculate absolute apparent wind direction (COG + AWA)
            const absoluteApparentWindDirection = cog + awa;

            // Create SVG arrow pointing towards where the apparent wind is coming from
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${absoluteApparentWindDirection})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="orange" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="orange" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'awa-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Load tracks from prompt dialog
        async function loadTracksFromPrompt() {
            const directoryInput = document.getElementById('prompt-directory');
            const directory = directoryInput.value.trim() || '.';

            try {
                // Save the new directory configuration
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ track_directory: directory })
                });

                if (!response.ok) {
                    throw new Error('Failed to update configuration');
                }

                // Show loading message
                document.getElementById('loading').innerHTML = '<div style="padding: 40px; text-align: center;"><h2>Loading tracks...</h2><p>Please wait...</p></div>';

                // Reload the page to refresh everything
                location.reload();

            } catch (error) {
                console.error('Error updating directory:', error);
                alert('Error updating directory: ' + error.message);
            }
        }

        // Update track directory configuration from Home tab
        async function updateTrackDirectory() {
            const directoryInput = document.getElementById('track-directory');
            const directory = directoryInput.value.trim() || '.';

            try {
                // Save the new directory configuration
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ track_directory: directory })
                });

                if (!response.ok) {
                    throw new Error('Failed to update configuration');
                }

                // Update status
                document.getElementById('directory-status').textContent = `Current: ${directory}`;

                // Show loading message
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').textContent = 'Loading tracks from new directory...';

                // Reload the page to refresh everything
                location.reload();

            } catch (error) {
                console.error('Error updating directory:', error);
                alert('Error updating directory: ' + error.message);
            }
        }

        // Auto-load annotations if available
        async function autoLoadAnnotations() {
            try {
                const response = await fetch('/api/annotations');
                const data = await response.json();

                if (data.status === 'success' && Array.isArray(data.annotations)) {
                    // Clear existing annotations
                    annotationMarkers.forEach(marker => map.removeLayer(marker));
                    annotationMarkers = [];
                    annotations = [];

                    // Load annotations from server
                    data.annotations.forEach(annotation => {
                        if (annotation.text && annotation.lat && annotation.lon && annotation.timestamp !== undefined && annotation.index !== undefined) {
                            annotations.push(annotation);

                            // Add marker to map
                            const annotationIcon = L.divIcon({
                                html: 'üìù',
                                iconSize: [24, 24],
                                className: 'annotation-marker',
                                iconAnchor: [12, 12]
                            });

                            const marker = L.marker([annotation.lat, annotation.lon], { icon: annotationIcon })
                                .addTo(map)
                                .on('click', function() {
                                    showAnnotationPopup(annotation);
                                });

                            annotationMarkers.push(marker);
                        }
                    });

                    // Update annotations list
                    updateAnnotationsList();

                    console.log(`Auto-loaded ${annotations.length} annotation(s) from ${data.file}`);
                } else if (data.status === 'not_found') {
                    console.log('No annotation file found in track directory');
                } else if (data.status === 'error') {
                    console.error('Error loading annotations:', data.message);
                }
            } catch (error) {
                console.error('Error auto-loading annotations:', error);
            }
        }

        // Initialize the map
        async function initMap() {
            try {
                // Load current configuration
                const configResponse = await fetch('/api/config');
                const config = await configResponse.json();
                const currentDirectory = config.track_directory || '.';

                // Update directory input and status
                document.getElementById('track-directory').value = currentDirectory;
                document.getElementById('directory-status').textContent = `Current: ${currentDirectory}`;

                // Fetch track data
                const response = await fetch('/api/tracks');
                const data = await response.json();
                tracks = data.tracks;
                bounds = data.bounds;

                // Check if we have any tracks
                if (tracks.length === 0) {
                    document.getElementById('loading').innerHTML = `
                        <div class="prompt-dialog">
                            <h2>üìÇ Welcome to Sailing Track Visualizer</h2>
                            <p>To get started, please enter the location of your tracking files.</p>
                            <div class="example">
                                <strong>Examples:</strong><br>
                                Current directory: .<br>
                                Windows: C:\\Users\\username\\Documents\\tracks<br>
                                Or: C:/Users/username/Documents/tracks<br>
                                Linux/Mac: /home/username/tracks
                            </div>
                            <input type="text" id="prompt-directory" placeholder="Enter directory path..." value="${currentDirectory}">
                            <button onclick="loadTracksFromPrompt()">Load Tracks</button>
                            <p style="margin-top: 20px; font-size: 12px; color: #999;">
                                Supported formats: JSON (export *.json) and GPX (*.gpx)
                            </p>
                        </div>
                    `;
                    return; // Don't initialize the map if there are no tracks
                }

                // Check if any track has sailing data
                hasSailingData = tracks.some(track => track.has_sailing_data);

                // Hide loading indicator
                document.getElementById('loading').style.display = 'none';

                // Create map centered on the tracks
                if (bounds) {
                    map = L.map('map').setView(
                        [bounds.center_lat, bounds.center_lon],
                        13
                    );
                } else {
                    map = L.map('map').setView([38.92, 20.89], 13);
                }

                // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                // Draw all tracks on the map with line style based on RPM
                tracks.forEach((track, index) => {
                    // Draw segments
                    for (let i = 0; i < track.points.length - 1; i++) {
                        const p1 = track.points[i];
                        const p2 = track.points[i + 1];

                        // Determine color based on whether sailing data is available
                        let segmentColor;
                        if (track.has_sailing_data) {
                            // If sailing data available: blue when rpm=0 (sailing), red when rpm>0 (motoring)
                            if (p1.rpm === 0 && p2.rpm === 0) {
                                segmentColor = 'blue'; // Blue for sailing
                            } else {
                                segmentColor = 'red'; // Red for motoring
                            }
                        } else {
                            // If only tracking data available: solid blue
                            segmentColor = 'blue';
                        }

                        const segment = L.polyline(
                            [[p1.lat, p1.lon], [p2.lat, p2.lon]],
                            {
                                color: segmentColor,
                                weight: 2,
                                opacity: 0.7
                            }
                        ).addTo(map);
                        trackPolylines.push(segment);
                    }

                    // Add start marker
                    if (track.points.length > 0) {
                        const start = track.points[0];
                        L.circleMarker([start.lat, start.lon], {
                            radius: 5,
                            color: 'green',
                            fillColor: 'green',
                            fillOpacity: 1
                        }).addTo(map).bindPopup(`Start: ${track.name}`);
                    }

                    // Add end marker
                    if (track.points.length > 0) {
                        const end = track.points[track.points.length - 1];
                        L.circleMarker([end.lat, end.lon], {
                            radius: 5,
                            color: 'red',
                            fillColor: 'red',
                            fillOpacity: 1
                        }).addTo(map).bindPopup(`End: ${track.name}`);
                    }

                    // Collect all points for animation
                    track.points.forEach(point => {
                        allPoints.push({
                            ...point,
                            trackName: track.name
                        });
                    });
                });

                // Sort all points chronologically by UTC timestamp
                allPoints.sort((a, b) => {
                    return new Date(a.utc) - new Date(b.utc);
                });

                // Calculate initial distance (at start position)
                calculateDistanceToCurrentPosition();

                // Fit map to bounds
                if (bounds) {
                    map.fitBounds([
                        [bounds.min_lat, bounds.min_lon],
                        [bounds.max_lat, bounds.max_lon]
                    ]);
                }

                // Hide or show UI elements based on sailing data availability
                if (!hasSailingData) {
                    // Hide arrow legend items
                    const arrowLegend = document.querySelector('.legend div:nth-child(2)');
                    if (arrowLegend) arrowLegend.style.display = 'none';

                    // Hide sailing-specific data rows in data panel (keep SOG and COG for GPX)
                    const sailingOnlyRows = ['rpm', 'twa', 'tws', 'awa', 'aws'];
                    sailingOnlyRows.forEach(id => {
                        const row = document.getElementById(`data-${id}`)?.parentElement;
                        if (row) row.style.display = 'none';
                    });

                    // Make sure SOG and COG are visible for GPX files with estimated values
                    ['sog', 'cog'].forEach(id => {
                        const row = document.getElementById(`data-${id}`)?.parentElement;
                        if (row) row.style.display = '';
                    });
                }

                // Add event listeners for arrow toggles (only if sailing data available)
                if (hasSailingData) {
                    document.getElementById('toggle-wind').addEventListener('change', (e) => {
                        showWindArrow = e.target.checked;
                        if (showWindArrow) {
                            windMarker.addTo(map);
                        } else {
                            map.removeLayer(windMarker);
                        }
                    });

                    document.getElementById('toggle-cog').addEventListener('change', (e) => {
                        showCogArrow = e.target.checked;
                        if (showCogArrow) {
                            cogMarker.addTo(map);
                        } else {
                            map.removeLayer(cogMarker);
                        }
                    });

                    document.getElementById('toggle-awa').addEventListener('change', (e) => {
                        showAwaArrow = e.target.checked;
                        if (showAwaArrow) {
                            awaMarker.addTo(map);
                        } else {
                            map.removeLayer(awaMarker);
                        }
                    });
                }

                // Create position markers
                if (allPoints.length > 0) {
                    const firstPoint = allPoints[0];

                    if (hasSailingData) {
                        // Create arrow markers for sailing data
                        const windArrowIcon = createArrowIcon(firstPoint.tws || 0, firstPoint.twa || 0, firstPoint.cog || 0);
                        windMarker = L.marker(
                            [firstPoint.lat, firstPoint.lon],
                            { icon: windArrowIcon }
                        ).addTo(map);

                        // Create COG arrow marker (green)
                        const cogArrowIcon = createCOGArrowIcon(firstPoint.sog || 0, firstPoint.cog || 0);
                        cogMarker = L.marker(
                            [firstPoint.lat, firstPoint.lon],
                            { icon: cogArrowIcon }
                        ).addTo(map);

                        // Create AWA arrow marker (orange)
                        const awaArrowIcon = createAWAArrowIcon(firstPoint.aws || 0, firstPoint.awa || 0, firstPoint.cog || 0);
                        awaMarker = L.marker(
                            [firstPoint.lat, firstPoint.lon],
                            { icon: awaArrowIcon }
                        ).addTo(map);
                    } else {
                        // Create simple boat position marker for GPX files (no sailing data)
                        const boatIcon = L.divIcon({
                            html: '‚õµ',
                            iconSize: [32, 32],
                            className: 'boat-marker',
                            iconAnchor: [16, 16]
                        });
                        boatMarker = L.marker(
                            [firstPoint.lat, firstPoint.lon],
                            { icon: boatIcon }
                        ).addTo(map);
                    }

                    // Initialize data panel with first point
                    updateDataDisplay(firstPoint);

                    // Initialize position slider
                    const positionSlider = document.getElementById('position-slider');
                    positionSlider.max = allPoints.length - 1;
                    positionSlider.value = 0;
                    document.getElementById('position-info').textContent = `${firstPoint.utc} (1/${allPoints.length})`;
                }

                // Add position slider event listener
                document.getElementById('position-slider').addEventListener('input', (e) => {
                    const newIndex = parseInt(e.target.value);
                    currentIndex = newIndex;

                    if (allPoints.length > 0) {
                        const point = allPoints[currentIndex];

                        // Update position markers
                        if (hasSailingData) {
                            // Update arrows (only if sailing data available)
                            windMarker.setLatLng([point.lat, point.lon]);
                            const newWindArrowIcon = createArrowIcon(point.tws || 0, point.twa || 0, point.cog || 0);
                            windMarker.setIcon(newWindArrowIcon);

                            cogMarker.setLatLng([point.lat, point.lon]);
                            const newCOGArrowIcon = createCOGArrowIcon(point.sog || 0, point.cog || 0);
                            cogMarker.setIcon(newCOGArrowIcon);

                            awaMarker.setLatLng([point.lat, point.lon]);
                            const newAWAArrowIcon = createAWAArrowIcon(point.aws || 0, point.awa || 0, point.cog || 0);
                            awaMarker.setIcon(newAWAArrowIcon);

                            // Pan if enabled
                            if (panEnabled) {
                                map.panTo([point.lat, point.lon]);
                            }
                        } else {
                            // Update boat marker for GPX files
                            if (boatMarker) {
                                boatMarker.setLatLng([point.lat, point.lon]);

                                // Pan if enabled
                                if (panEnabled) {
                                    map.panTo([point.lat, point.lon]);
                                }
                            }
                        }

                        // Update data display
                        updateDataDisplay(point);

                        // Update distance from start to current position
                        calculateDistanceToCurrentPosition();

                        // Update position info with timestamp
                        document.getElementById('position-info').textContent = `${point.utc} (${currentIndex + 1}/${allPoints.length})`;
                    }
                });

                // No animation polyline - boat marker only to preserve original track visibility

                // Auto-load annotations if available
                await autoLoadAnnotations();

            } catch (error) {
                console.error('Error loading tracks:', error);
                document.getElementById('loading').textContent = 'Error loading tracks!';
            }
        }


        // Animation functions
        function startAnimation() {
            if (animationInterval) return;

            document.getElementById('play-btn').disabled = true;
            document.getElementById('pause-btn').disabled = false;

            const baseDelay = 50; // Base delay in milliseconds
            const delay = baseDelay / speed;

            animationInterval = setInterval(() => {
                // Check bounds based on direction
                if (direction === 1 && currentIndex >= allPoints.length) {
                    stopAnimation();
                    return;
                }
                if (direction === -1 && currentIndex < 0) {
                    stopAnimation();
                    return;
                }

                const point = allPoints[currentIndex];

                // Update position markers
                if (hasSailingData) {
                    // Update arrow positions and icons (only if sailing data available)
                    // Update wind arrow position and icon (blue)
                    windMarker.setLatLng([point.lat, point.lon]);
                    const newWindArrowIcon = createArrowIcon(point.tws || 0, point.twa || 0, point.cog || 0);
                    windMarker.setIcon(newWindArrowIcon);

                    // Update COG arrow position and icon (green)
                    cogMarker.setLatLng([point.lat, point.lon]);
                    const newCOGArrowIcon = createCOGArrowIcon(point.sog || 0, point.cog || 0);
                    cogMarker.setIcon(newCOGArrowIcon);

                    // Update AWA arrow position and icon (orange)
                    awaMarker.setLatLng([point.lat, point.lon]);
                    const newAWAArrowIcon = createAWAArrowIcon(point.aws || 0, point.awa || 0, point.cog || 0);
                    awaMarker.setIcon(newAWAArrowIcon);

                    // Pan map to center on current position if enabled
                    if (panEnabled) {
                        map.panTo([point.lat, point.lon]);
                    }
                } else {
                    // Update simple boat marker for GPX files
                    if (boatMarker) {
                        boatMarker.setLatLng([point.lat, point.lon]);

                        // Pan map to center on current position if enabled
                        if (panEnabled) {
                            map.panTo([point.lat, point.lon]);
                        }
                    }
                }

                // Update info in bottom bar and right sidebar
                document.getElementById('progress-info').textContent =
                    `Point ${currentIndex + 1} of ${allPoints.length} (${((currentIndex / allPoints.length) * 100).toFixed(1)}%)`;

                // Update data panel in sidebar
                updateDataDisplay(point);

                // Update distance from start to current position
                calculateDistanceToCurrentPosition();

                // Update position slider
                document.getElementById('position-slider').value = currentIndex;
                document.getElementById('position-info').textContent = `${point.utc} (${currentIndex + 1}/${allPoints.length})`;

                currentIndex += direction;
            }, delay);
        }

        function pauseAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
                document.getElementById('play-btn').disabled = false;
                document.getElementById('pause-btn').disabled = true;
            }
        }

        function stopAnimation() {
            pauseAnimation();
            document.getElementById('progress-info').textContent = 'Animation complete!';
        }

        function resetAnimation() {
            pauseAnimation();
            currentIndex = 0;
            direction = 1;

            // Reset Reverse button appearance
            const reverseBtn = document.getElementById('reverse-btn');
            reverseBtn.style.background = '#007bff';
            reverseBtn.textContent = 'Reverse';

            if (allPoints.length > 0) {
                const firstPoint = allPoints[0];

                // Update position markers
                if (hasSailingData) {
                    // Update arrows (only if sailing data available)
                    windMarker.setLatLng([firstPoint.lat, firstPoint.lon]);
                    cogMarker.setLatLng([firstPoint.lat, firstPoint.lon]);
                    awaMarker.setLatLng([firstPoint.lat, firstPoint.lon]);
                } else {
                    // Update boat marker for GPX files
                    if (boatMarker) {
                        boatMarker.setLatLng([firstPoint.lat, firstPoint.lon]);
                    }
                }

                // Center map at start position
                map.panTo([firstPoint.lat, firstPoint.lon]);

                // Update data display
                updateDataDisplay(firstPoint);

                // Update distance (should be 0 at start)
                calculateDistanceToCurrentPosition();

                // Update position slider
                document.getElementById('position-slider').value = 0;
                document.getElementById('position-info').textContent = `${firstPoint.utc} (1/${allPoints.length})`;
            }

            document.getElementById('progress-info').textContent = 'Ready to play';
            document.getElementById('play-btn').disabled = false;
        }

        // Event listeners
        document.getElementById('play-btn').addEventListener('click', startAnimation);
        document.getElementById('pause-btn').addEventListener('click', pauseAnimation);
        document.getElementById('reset-btn').addEventListener('click', resetAnimation);

        document.getElementById('pan-btn').addEventListener('click', () => {
            panEnabled = !panEnabled;
            const btn = document.getElementById('pan-btn');
            if (panEnabled) {
                btn.style.background = '#28a745';
                btn.textContent = 'Pan: ON';
            } else {
                btn.style.background = '#007bff';
                btn.textContent = 'Pan';
            }
        });

        document.getElementById('reverse-btn').addEventListener('click', () => {
            direction = -direction;
            const btn = document.getElementById('reverse-btn');
            if (direction === -1) {
                btn.style.background = '#ffc107';
                btn.textContent = 'Reverse: ON';
            } else {
                btn.style.background = '#007bff';
                btn.textContent = 'Reverse';
            }

            // Restart animation with new direction if currently playing
            if (animationInterval) {
                pauseAnimation();
                startAnimation();
            }
        });

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);
            speed = getSpeedMultiplier(sliderValue);
            document.getElementById('speed-value').textContent = getSpeedLabel(sliderValue);

            // Restart animation with new speed if currently playing
            if (animationInterval) {
                pauseAnimation();
                startAnimation();
            }
        });

        // Convert GPS coordinates from EXIF format to decimal degrees
        function convertDMSToDD(degrees, minutes, seconds, direction) {
            let dd = degrees + minutes / 60 + seconds / 3600;
            if (direction === 'S' || direction === 'W') {
                dd = dd * -1;
            }
            return dd;
        }

        // Format EXIF date to yyyy-mm-dd HH:MM:SS
        function formatExifDate(exifDate) {
            if (!exifDate) return '';
            // EXIF format is "YYYY:MM:DD HH:MM:SS"
            // Convert to "YYYY-MM-DD HH:MM:SS"
            return exifDate.replace(/^(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3');
        }

        // Open photo modal with full resolution image
        function openPhotoModal(imageSrc, fileName, dateTime) {
            const modal = document.getElementById('photo-modal');
            const modalImg = document.getElementById('modal-image');
            const modalInfo = document.getElementById('modal-info');

            modal.style.display = 'block';
            modalImg.src = imageSrc;
            const formattedDate = formatExifDate(dateTime);
            modalInfo.innerHTML = `<div>${fileName}</div>${formattedDate ? `<div style="font-size: 12px; margin-top: 5px;">${formattedDate}</div>` : ''}`;
        }

        // Close photo modal
        function closePhotoModal() {
            document.getElementById('photo-modal').style.display = 'none';
        }

        // Close modal when clicking outside the image
        window.onclick = function(event) {
            const modal = document.getElementById('photo-modal');
            if (event.target === modal) {
                closePhotoModal();
            }
        }

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closePhotoModal();
            }
        });

        // Handle photo upload and extract GPS data
        function handlePhotoUpload(event) {
            const files = event.target.files;
            if (files.length === 0) return;

            let photosWithGPS = 0;
            let photosProcessed = 0;

            // Clear existing photo markers
            photoMarkers.forEach(marker => map.removeLayer(marker));
            photoMarkers = [];

            Array.from(files).forEach(file => {
                if (!file.type.startsWith('image/')) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.src = e.target.result;

                    img.onload = function() {
                        EXIF.getData(img, function() {
                            const lat = EXIF.getTag(this, 'GPSLatitude');
                            const latRef = EXIF.getTag(this, 'GPSLatitudeRef');
                            const lon = EXIF.getTag(this, 'GPSLongitude');
                            const lonRef = EXIF.getTag(this, 'GPSLongitudeRef');
                            const dateTime = EXIF.getTag(this, 'DateTime');

                            photosProcessed++;

                            if (lat && lon && latRef && lonRef) {
                                const latitude = convertDMSToDD(lat[0], lat[1], lat[2], latRef);
                                const longitude = convertDMSToDD(lon[0], lon[1], lon[2], lonRef);

                                // Create camera icon for photo marker
                                const photoIcon = L.divIcon({
                                    html: 'üì∑',
                                    iconSize: [24, 24],
                                    className: 'photo-marker',
                                    iconAnchor: [12, 12]
                                });

                                // Add marker to map - clicking marker opens full-res photo
                                const marker = L.marker([latitude, longitude], { icon: photoIcon })
                                    .addTo(map)
                                    .on('click', function() {
                                        openPhotoModal(e.target.result, file.name, dateTime);
                                    });

                                // Create popup with photo thumbnail (clicking thumbnail also opens full-res)
                                const formattedDate = formatExifDate(dateTime);
                                const popupContent = `
                                    <div style="text-align: center; cursor: pointer;" onclick="openPhotoModal('${e.target.result}', '${file.name}', '${dateTime || ''}')">
                                        <img src="${e.target.result}" style="max-width: 200px; max-height: 200px; display: block; margin-bottom: 5px;">
                                        <div style="font-size: 11px; color: #666;">${file.name}</div>
                                        ${formattedDate ? `<div style="font-size: 10px; color: #999;">${formattedDate}</div>` : ''}
                                        <div style="font-size: 9px; color: #007bff; margin-top: 3px;">Click to view full size</div>
                                    </div>
                                `;
                                marker.bindPopup(popupContent);

                                photoMarkers.push(marker);
                                photosWithGPS++;
                            }

                            // Update status after all photos processed
                            if (photosProcessed === files.length) {
                                document.getElementById('photo-status').textContent =
                                    `Loaded ${photosWithGPS} of ${files.length} photos with GPS data`;
                            }
                        });
                    };
                };
                reader.readAsDataURL(file);
            });
        }

        // Add event listener for photo upload
        document.getElementById('photo-upload').addEventListener('change', handlePhotoUpload);

        // Initialize on page load
        window.addEventListener('load', initMap);

        // Resize handle functionality
        (function() {
            const resizeHandle = document.getElementById('resize-handle');
            const sidebar = document.getElementById('right-sidebar');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            resizeHandle.addEventListener('mousedown', function(e) {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;

                // Calculate new width (subtract because we're dragging from the left edge)
                const diff = startX - e.clientX;
                const newWidth = startWidth + diff;

                // Apply constraints
                const minWidth = 200;
                const maxWidth = 600;
                const constrainedWidth = Math.min(Math.max(newWidth, minWidth), maxWidth);

                sidebar.style.width = constrainedWidth + 'px';

                // Invalidate map size so Leaflet adjusts
                if (map) {
                    setTimeout(() => map.invalidateSize(), 0);
                }
            });

            document.addEventListener('mouseup', function() {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });

            // Touch support for mobile
            resizeHandle.addEventListener('touchstart', function(e) {
                isResizing = true;
                startX = e.touches[0].clientX;
                startWidth = sidebar.offsetWidth;
                e.preventDefault();
            });

            document.addEventListener('touchmove', function(e) {
                if (!isResizing) return;

                const diff = startX - e.touches[0].clientX;
                const newWidth = startWidth + diff;

                const minWidth = 200;
                const maxWidth = 600;
                const constrainedWidth = Math.min(Math.max(newWidth, minWidth), maxWidth);

                sidebar.style.width = constrainedWidth + 'px';

                if (map) {
                    setTimeout(() => map.invalidateSize(), 0);
                }
            });

            document.addEventListener('touchend', function() {
                if (isResizing) {
                    isResizing = false;
                }
            });
        })();
    </script>
</body>
</html>
