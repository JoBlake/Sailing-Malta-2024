<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sailing Track Visualizer</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        #map {
            flex: 1;
        }

        .right-sidebar {
            width: 280px;
            background: white;
            border-left: 2px solid #ddd;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .controls {
            background: white;
            padding: 15px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #speed-slider {
            width: 150px;
        }

        .info {
            font-size: 12px;
            color: #333;
            flex: 1;
            min-width: 200px;
        }

        .wind-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wind-arrow svg {
            display: block;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .legend {
            font-size: 12px;
            line-height: 1.5;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
        }

        .data-panel {
            font-size: 11px;
        }

        .data-panel-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 2px solid #28a745;
            padding-bottom: 5px;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }

        .data-label {
            font-weight: 600;
            color: #555;
        }

        .data-value {
            color: #000;
            font-family: monospace;
        }

        .legend-scale {
            display: flex;
            height: 20px;
            margin: 5px 0;
            border: 1px solid #ccc;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .legend-note {
            margin-top: 5px;
            font-size: 10px;
            font-style: italic;
            color: #666;
        }

        .photo-marker {
            font-size: 24px;
            text-align: center;
            cursor: pointer;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));
        }

        .photo-marker:hover {
            transform: scale(1.2);
        }

        .photo-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            right: 280px; /* Leave space for right sidebar */
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            overflow: auto;
        }

        .photo-modal-content {
            margin: auto;
            display: block;
            max-width: 90%;
            max-height: 90%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .photo-modal-close {
            position: absolute;
            top: 20px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 2001;
        }

        .photo-modal-close:hover,
        .photo-modal-close:focus {
            color: #bbb;
        }

        .photo-modal-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading tracks...</div>

    <!-- Photo Modal -->
    <div id="photo-modal" class="photo-modal">
        <span class="photo-modal-close" onclick="closePhotoModal()">&times;</span>
        <img class="photo-modal-content" id="modal-image">
        <div class="photo-modal-info" id="modal-info"></div>
    </div>

    <div class="main-content">
        <div id="map"></div>

        <div class="right-sidebar">
            <div class="legend">
                <div class="legend-title">Legend</div>
                <div style="margin-top: 5px;">
                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #555;">Arrows:</div>
                    <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 8px;">
                        <input type="checkbox" id="toggle-wind" checked style="cursor: pointer;">
                        <svg width="30" height="16" xmlns="http://www.w3.org/2000/svg">
                            <line x1="3" y1="8" x2="20" y2="8" stroke="blue" stroke-width="3"/>
                            <path d="M 20,8 L 15,5 L 17,8 L 15,11 Z" fill="blue"/>
                        </svg>
                        <span style="font-size: 11px;">True Wind (TWA/TWS)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 8px;">
                        <input type="checkbox" id="toggle-cog" checked style="cursor: pointer;">
                        <svg width="30" height="16" xmlns="http://www.w3.org/2000/svg">
                            <line x1="3" y1="8" x2="20" y2="8" stroke="green" stroke-width="3"/>
                            <path d="M 20,8 L 15,5 L 17,8 L 15,11 Z" fill="green"/>
                        </svg>
                        <span style="font-size: 11px;">Boat (COG/SOG)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 15px;">
                        <input type="checkbox" id="toggle-awa" checked style="cursor: pointer;">
                        <svg width="30" height="16" xmlns="http://www.w3.org/2000/svg">
                            <line x1="3" y1="8" x2="20" y2="8" stroke="orange" stroke-width="3"/>
                            <path d="M 20,8 L 15,5 L 17,8 L 15,11 Z" fill="orange"/>
                        </svg>
                        <span style="font-size: 11px;">Apparent Wind (AWA/AWS)</span>
                    </div>

                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #555;">Track Lines:</div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                        <svg width="40" height="16" xmlns="http://www.w3.org/2000/svg">
                            <line x1="3" y1="8" x2="37" y2="8" stroke="blue" stroke-width="3"/>
                        </svg>
                        <span style="font-size: 11px;">Sailing (RPM=0)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <svg width="40" height="16" xmlns="http://www.w3.org/2000/svg">
                            <line x1="3" y1="8" x2="37" y2="8" stroke="red" stroke-width="3"/>
                        </svg>
                        <span style="font-size: 11px;">Motoring (RPM>0)</span>
                    </div>
                </div>
            </div>

            <div class="data-panel">
                <div class="data-panel-title">Current Data</div>
                <div id="data-display">
                    <div class="data-row"><span class="data-label">Time:</span><span class="data-value" id="data-time">--</span></div>
                    <div class="data-row"><span class="data-label">Latitude:</span><span class="data-value" id="data-lat">--</span></div>
                    <div class="data-row"><span class="data-label">Longitude:</span><span class="data-value" id="data-lon">--</span></div>
                    <div class="data-row"><span class="data-label">RPM:</span><span class="data-value" id="data-rpm">--</span></div>
                    <div class="data-row"><span class="data-label">COG:</span><span class="data-value" id="data-cog">--</span></div>
                    <div class="data-row"><span class="data-label">SOG:</span><span class="data-value" id="data-sog">--</span></div>
                    <div class="data-row"><span class="data-label">TWA:</span><span class="data-value" id="data-twa">--</span></div>
                    <div class="data-row"><span class="data-label">TWS:</span><span class="data-value" id="data-tws">--</span></div>
                    <div class="data-row"><span class="data-label">AWA:</span><span class="data-value" id="data-awa">--</span></div>
                    <div class="data-row"><span class="data-label">AWS:</span><span class="data-value" id="data-aws">--</span></div>
                </div>
            </div>

            <div class="data-panel">
                <div class="data-panel-title">Position Control</div>
                <div style="font-size: 11px; padding: 5px 0;">
                    <label for="position-slider" style="display: block; margin-bottom: 5px; font-weight: 600; color: #555;">Track Position:</label>
                    <input type="range" id="position-slider" min="0" max="100" value="0" style="width: 100%; cursor: pointer;">
                    <div id="position-info" style="font-size: 10px; color: #666; margin-top: 5px; text-align: center;">Point 0 of 0</div>
                </div>
            </div>

            <div class="photo-panel">
                <div class="data-panel-title">Photos</div>
                <div style="font-size: 11px;">
                    <label for="photo-upload" style="display: block; margin-bottom: 8px; cursor: pointer; padding: 8px; background: #007bff; color: white; text-align: center; border-radius: 4px;">
                        Select Photos
                        <input type="file" id="photo-upload" multiple accept="image/*" style="display: none;">
                    </label>
                    <div id="photo-status" style="font-size: 10px; color: #666; margin-top: 5px;">No photos loaded</div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button id="play-btn">Play</button>
        <button id="pause-btn" disabled>Pause</button>
        <button id="reset-btn">Reset</button>
        <button id="reverse-btn">Reverse</button>
        <button id="pan-btn">Pan</button>

        <div class="speed-control">
            <label for="speed-slider">Speed:</label>
            <input type="range" id="speed-slider" min="1" max="7" value="4" step="1" />
            <span id="speed-value">1x</span>
        </div>

        <div class="info">
            <span id="progress-info">Ready to play</span>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- EXIF.js for reading GPS data from photos -->
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>

    <script>
        let map;
        let tracks = [];
        let bounds = null;
        let allPoints = [];
        let currentIndex = 0;
        let animationInterval = null;
        let windMarker = null;
        let cogMarker = null;
        let awaMarker = null;
        let trackPolylines = [];
        let speed = 1;
        let panEnabled = false;
        let direction = 1; // 1 for forward, -1 for reverse
        let showWindArrow = true;
        let showCogArrow = true;
        let showAwaArrow = true;
        let photoMarkers = [];

        // Helper function to update data display
        function updateDataDisplay(point) {
            document.getElementById('data-time').textContent = point.utc;
            document.getElementById('data-lat').textContent = point.lat.toFixed(6) + 'Â°';
            document.getElementById('data-lon').textContent = point.lon.toFixed(6) + 'Â°';
            document.getElementById('data-rpm').textContent = point.rpm;
            document.getElementById('data-cog').textContent = point.cog.toFixed(1) + 'Â°';
            document.getElementById('data-sog').textContent = point.sog.toFixed(2) + ' kt';
            document.getElementById('data-twa').textContent = point.twa.toFixed(1) + 'Â°';
            document.getElementById('data-tws').textContent = point.tws.toFixed(1) + ' kt';
            document.getElementById('data-awa').textContent = point.awa.toFixed(1) + 'Â°';
            document.getElementById('data-aws').textContent = point.aws.toFixed(2) + ' kt';
        }

        // Map slider values (1-7) to speed multipliers
        function getSpeedMultiplier(sliderValue) {
            const speedMap = {
                1: 0.125,  // 1/8x
                2: 0.25,   // 1/4x
                3: 0.5,    // 1/2x
                4: 1,      // 1x
                5: 2,      // 2x
                6: 4,      // 4x
                7: 8       // 8x
            };
            return speedMap[sliderValue] || 1;
        }

        // Get display label for speed
        function getSpeedLabel(sliderValue) {
            const labelMap = {
                1: '1/8x',
                2: '1/4x',
                3: '1/2x',
                4: '1x',
                5: '2x',
                6: '4x',
                7: '8x'
            };
            return labelMap[sliderValue] || '1x';
        }

        // Create wind arrow icon
        // tws: True Wind Speed
        // twa: True Wind Angle (degrees) - relative to boat heading
        // cog: Course Over Ground (degrees) - boat's heading/direction
        function createArrowIcon(tws, twa, cog) {
            // Calculate arrow length based on TWS with truly proportional scaling
            // Use unified scale: 0-20 knots for consistency across all arrows
            const minLength = 10; // Small minimum for visibility
            const maxLength = 80;
            const maxScale = 20; // Maximum knots for scaling
            const normalized = Math.min(tws / maxScale, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Calculate absolute wind direction (COG + TWA)
            const absoluteWindDirection = cog + twa;

            // Create SVG arrow pointing towards where the wind is coming from
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${absoluteWindDirection})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="blue" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="blue" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'wind-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Create COG arrow icon (Course Over Ground)
        // cog: Course Over Ground (degrees)
        // sog: Speed Over Ground (knots)
        function createCOGArrowIcon(sog, cog) {
            // Calculate arrow length based on SOG with truly proportional scaling
            // Use unified scale: 0-20 knots for consistency across all arrows
            const minLength = 10; // Small minimum for visibility
            const maxLength = 80;
            const maxScale = 20; // Maximum knots for scaling
            const normalized = Math.min(sog / maxScale, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Create SVG arrow pointing upward (will be rotated by COG)
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${cog})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="green" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="green" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'cog-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Create AWA arrow icon (Apparent Wind Angle)
        // aws: Apparent Wind Speed (knots)
        // awa: Apparent Wind Angle (degrees) - relative to boat heading
        // cog: Course Over Ground (degrees) - boat's heading/direction
        function createAWAArrowIcon(aws, awa, cog) {
            // Calculate arrow length based on AWS with truly proportional scaling
            // Use unified scale: 0-20 knots for consistency across all arrows
            const minLength = 10; // Small minimum for visibility
            const maxLength = 80;
            const maxScale = 20; // Maximum knots for scaling
            const normalized = Math.min(aws / maxScale, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Calculate absolute apparent wind direction (COG + AWA)
            const absoluteApparentWindDirection = cog + awa;

            // Create SVG arrow pointing towards where the apparent wind is coming from
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${absoluteApparentWindDirection})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="orange" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="orange" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'awa-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Initialize the map
        async function initMap() {
            try {
                // Fetch track data
                const response = await fetch('/api/tracks');
                const data = await response.json();
                tracks = data.tracks;
                bounds = data.bounds;

                // Hide loading indicator
                document.getElementById('loading').style.display = 'none';

                // Create map centered on the tracks
                if (bounds) {
                    map = L.map('map').setView(
                        [bounds.center_lat, bounds.center_lon],
                        13
                    );
                } else {
                    map = L.map('map').setView([38.92, 20.89], 13);
                }

                // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                // Draw all tracks on the map with line style based on RPM
                tracks.forEach((track, index) => {
                    // Draw segments: blue when rpm=0 (sailing), red when rpm>0 (motoring)
                    for (let i = 0; i < track.points.length - 1; i++) {
                        const p1 = track.points[i];
                        const p2 = track.points[i + 1];

                        // Determine color based on RPM
                        let segmentColor;
                        if (p1.rpm === 0 && p2.rpm === 0) {
                            segmentColor = 'blue'; // Blue for sailing
                        } else {
                            segmentColor = 'red'; // Red for motoring
                        }

                        const segment = L.polyline(
                            [[p1.lat, p1.lon], [p2.lat, p2.lon]],
                            {
                                color: segmentColor,
                                weight: 2,
                                opacity: 0.7
                            }
                        ).addTo(map);
                        trackPolylines.push(segment);
                    }

                    // Add start marker
                    if (track.points.length > 0) {
                        const start = track.points[0];
                        L.circleMarker([start.lat, start.lon], {
                            radius: 5,
                            color: 'green',
                            fillColor: 'green',
                            fillOpacity: 1
                        }).addTo(map).bindPopup(`Start: ${track.name}`);
                    }

                    // Add end marker
                    if (track.points.length > 0) {
                        const end = track.points[track.points.length - 1];
                        L.circleMarker([end.lat, end.lon], {
                            radius: 5,
                            color: 'red',
                            fillColor: 'red',
                            fillOpacity: 1
                        }).addTo(map).bindPopup(`End: ${track.name}`);
                    }

                    // Collect all points for animation
                    track.points.forEach(point => {
                        allPoints.push({
                            ...point,
                            trackName: track.name
                        });
                    });
                });

                // Sort all points chronologically by UTC timestamp
                allPoints.sort((a, b) => {
                    return new Date(a.utc) - new Date(b.utc);
                });

                // Fit map to bounds
                if (bounds) {
                    map.fitBounds([
                        [bounds.min_lat, bounds.min_lon],
                        [bounds.max_lat, bounds.max_lon]
                    ]);
                }

                // Add event listeners for arrow toggles
                document.getElementById('toggle-wind').addEventListener('change', (e) => {
                    showWindArrow = e.target.checked;
                    if (showWindArrow) {
                        windMarker.addTo(map);
                    } else {
                        map.removeLayer(windMarker);
                    }
                });

                document.getElementById('toggle-cog').addEventListener('change', (e) => {
                    showCogArrow = e.target.checked;
                    if (showCogArrow) {
                        cogMarker.addTo(map);
                    } else {
                        map.removeLayer(cogMarker);
                    }
                });

                document.getElementById('toggle-awa').addEventListener('change', (e) => {
                    showAwaArrow = e.target.checked;
                    if (showAwaArrow) {
                        awaMarker.addTo(map);
                    } else {
                        map.removeLayer(awaMarker);
                    }
                });

                // Create wind arrow marker (blue)
                if (allPoints.length > 0) {
                    const firstPoint = allPoints[0];
                    const windArrowIcon = createArrowIcon(firstPoint.tws, firstPoint.twa, firstPoint.cog);
                    windMarker = L.marker(
                        [firstPoint.lat, firstPoint.lon],
                        { icon: windArrowIcon }
                    ).addTo(map);

                    // Create COG arrow marker (green)
                    const cogArrowIcon = createCOGArrowIcon(firstPoint.sog, firstPoint.cog);
                    cogMarker = L.marker(
                        [firstPoint.lat, firstPoint.lon],
                        { icon: cogArrowIcon }
                    ).addTo(map);

                    // Create AWA arrow marker (orange)
                    const awaArrowIcon = createAWAArrowIcon(firstPoint.aws, firstPoint.awa, firstPoint.cog);
                    awaMarker = L.marker(
                        [firstPoint.lat, firstPoint.lon],
                        { icon: awaArrowIcon }
                    ).addTo(map);

                    // Initialize data panel with first point
                    updateDataDisplay(firstPoint);

                    // Initialize position slider
                    const positionSlider = document.getElementById('position-slider');
                    positionSlider.max = allPoints.length - 1;
                    positionSlider.value = 0;
                    document.getElementById('position-info').textContent = `${firstPoint.utc} (1/${allPoints.length})`;
                }

                // Add position slider event listener
                document.getElementById('position-slider').addEventListener('input', (e) => {
                    const newIndex = parseInt(e.target.value);
                    currentIndex = newIndex;

                    if (allPoints.length > 0) {
                        const point = allPoints[currentIndex];

                        // Update arrows
                        windMarker.setLatLng([point.lat, point.lon]);
                        const newWindArrowIcon = createArrowIcon(point.tws, point.twa, point.cog);
                        windMarker.setIcon(newWindArrowIcon);

                        cogMarker.setLatLng([point.lat, point.lon]);
                        const newCOGArrowIcon = createCOGArrowIcon(point.sog, point.cog);
                        cogMarker.setIcon(newCOGArrowIcon);

                        awaMarker.setLatLng([point.lat, point.lon]);
                        const newAWAArrowIcon = createAWAArrowIcon(point.aws, point.awa, point.cog);
                        awaMarker.setIcon(newAWAArrowIcon);

                        // Pan if enabled
                        if (panEnabled) {
                            map.panTo([point.lat, point.lon]);
                        }

                        // Update data display
                        updateDataDisplay(point);

                        // Update position info with timestamp
                        document.getElementById('position-info').textContent = `${point.utc} (${currentIndex + 1}/${allPoints.length})`;
                    }
                });

                // No animation polyline - boat marker only to preserve original track visibility

            } catch (error) {
                console.error('Error loading tracks:', error);
                document.getElementById('loading').textContent = 'Error loading tracks!';
            }
        }


        // Animation functions
        function startAnimation() {
            if (animationInterval) return;

            document.getElementById('play-btn').disabled = true;
            document.getElementById('pause-btn').disabled = false;

            const baseDelay = 50; // Base delay in milliseconds
            const delay = baseDelay / speed;

            animationInterval = setInterval(() => {
                // Check bounds based on direction
                if (direction === 1 && currentIndex >= allPoints.length) {
                    stopAnimation();
                    return;
                }
                if (direction === -1 && currentIndex < 0) {
                    stopAnimation();
                    return;
                }

                const point = allPoints[currentIndex];

                // Update wind arrow position and icon (blue)
                windMarker.setLatLng([point.lat, point.lon]);
                const newWindArrowIcon = createArrowIcon(point.tws, point.twa, point.cog);
                windMarker.setIcon(newWindArrowIcon);

                // Update COG arrow position and icon (green)
                cogMarker.setLatLng([point.lat, point.lon]);
                const newCOGArrowIcon = createCOGArrowIcon(point.sog, point.cog);
                cogMarker.setIcon(newCOGArrowIcon);

                // Update AWA arrow position and icon (orange)
                awaMarker.setLatLng([point.lat, point.lon]);
                const newAWAArrowIcon = createAWAArrowIcon(point.aws, point.awa, point.cog);
                awaMarker.setIcon(newAWAArrowIcon);

                // Pan map to center on current position if enabled
                if (panEnabled) {
                    map.panTo([point.lat, point.lon]);
                }

                // Update info in bottom bar and right sidebar
                document.getElementById('progress-info').textContent =
                    `Point ${currentIndex + 1} of ${allPoints.length} (${((currentIndex / allPoints.length) * 100).toFixed(1)}%)`;

                // Update data panel in sidebar
                updateDataDisplay(point);

                // Update position slider
                document.getElementById('position-slider').value = currentIndex;
                document.getElementById('position-info').textContent = `${point.utc} (${currentIndex + 1}/${allPoints.length})`;

                currentIndex += direction;
            }, delay);
        }

        function pauseAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
                document.getElementById('play-btn').disabled = false;
                document.getElementById('pause-btn').disabled = true;
            }
        }

        function stopAnimation() {
            pauseAnimation();
            document.getElementById('progress-info').textContent = 'Animation complete!';
        }

        function resetAnimation() {
            pauseAnimation();
            currentIndex = 0;
            direction = 1;

            // Reset Reverse button appearance
            const reverseBtn = document.getElementById('reverse-btn');
            reverseBtn.style.background = '#007bff';
            reverseBtn.textContent = 'Reverse';

            if (allPoints.length > 0) {
                const firstPoint = allPoints[0];
                windMarker.setLatLng([firstPoint.lat, firstPoint.lon]);
                cogMarker.setLatLng([firstPoint.lat, firstPoint.lon]);
                awaMarker.setLatLng([firstPoint.lat, firstPoint.lon]);

                // Center map at start position
                map.panTo([firstPoint.lat, firstPoint.lon]);

                // Update data display
                updateDataDisplay(firstPoint);

                // Update position slider
                document.getElementById('position-slider').value = 0;
                document.getElementById('position-info').textContent = `${firstPoint.utc} (1/${allPoints.length})`;
            }

            document.getElementById('progress-info').textContent = 'Ready to play';
            document.getElementById('play-btn').disabled = false;
        }

        // Event listeners
        document.getElementById('play-btn').addEventListener('click', startAnimation);
        document.getElementById('pause-btn').addEventListener('click', pauseAnimation);
        document.getElementById('reset-btn').addEventListener('click', resetAnimation);

        document.getElementById('pan-btn').addEventListener('click', () => {
            panEnabled = !panEnabled;
            const btn = document.getElementById('pan-btn');
            if (panEnabled) {
                btn.style.background = '#28a745';
                btn.textContent = 'Pan: ON';
            } else {
                btn.style.background = '#007bff';
                btn.textContent = 'Pan';
            }
        });

        document.getElementById('reverse-btn').addEventListener('click', () => {
            direction = -direction;
            const btn = document.getElementById('reverse-btn');
            if (direction === -1) {
                btn.style.background = '#ffc107';
                btn.textContent = 'Reverse: ON';
            } else {
                btn.style.background = '#007bff';
                btn.textContent = 'Reverse';
            }

            // Restart animation with new direction if currently playing
            if (animationInterval) {
                pauseAnimation();
                startAnimation();
            }
        });

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);
            speed = getSpeedMultiplier(sliderValue);
            document.getElementById('speed-value').textContent = getSpeedLabel(sliderValue);

            // Restart animation with new speed if currently playing
            if (animationInterval) {
                pauseAnimation();
                startAnimation();
            }
        });

        // Convert GPS coordinates from EXIF format to decimal degrees
        function convertDMSToDD(degrees, minutes, seconds, direction) {
            let dd = degrees + minutes / 60 + seconds / 3600;
            if (direction === 'S' || direction === 'W') {
                dd = dd * -1;
            }
            return dd;
        }

        // Format EXIF date to yyyy-mm-dd
        function formatExifDate(exifDate) {
            if (!exifDate) return '';
            // EXIF format is "YYYY:MM:DD HH:MM:SS"
            // Convert to "YYYY-MM-DD"
            return exifDate.substring(0, 10).replace(/:/g, '-');
        }

        // Open photo modal with full resolution image
        function openPhotoModal(imageSrc, fileName, dateTime) {
            const modal = document.getElementById('photo-modal');
            const modalImg = document.getElementById('modal-image');
            const modalInfo = document.getElementById('modal-info');

            modal.style.display = 'block';
            modalImg.src = imageSrc;
            const formattedDate = formatExifDate(dateTime);
            modalInfo.innerHTML = `<div>${fileName}</div>${formattedDate ? `<div style="font-size: 12px; margin-top: 5px;">${formattedDate}</div>` : ''}`;
        }

        // Close photo modal
        function closePhotoModal() {
            document.getElementById('photo-modal').style.display = 'none';
        }

        // Close modal when clicking outside the image
        window.onclick = function(event) {
            const modal = document.getElementById('photo-modal');
            if (event.target === modal) {
                closePhotoModal();
            }
        }

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closePhotoModal();
            }
        });

        // Handle photo upload and extract GPS data
        function handlePhotoUpload(event) {
            const files = event.target.files;
            if (files.length === 0) return;

            let photosWithGPS = 0;
            let photosProcessed = 0;

            // Clear existing photo markers
            photoMarkers.forEach(marker => map.removeLayer(marker));
            photoMarkers = [];

            Array.from(files).forEach(file => {
                if (!file.type.startsWith('image/')) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.src = e.target.result;

                    img.onload = function() {
                        EXIF.getData(img, function() {
                            const lat = EXIF.getTag(this, 'GPSLatitude');
                            const latRef = EXIF.getTag(this, 'GPSLatitudeRef');
                            const lon = EXIF.getTag(this, 'GPSLongitude');
                            const lonRef = EXIF.getTag(this, 'GPSLongitudeRef');
                            const dateTime = EXIF.getTag(this, 'DateTime');

                            photosProcessed++;

                            if (lat && lon && latRef && lonRef) {
                                const latitude = convertDMSToDD(lat[0], lat[1], lat[2], latRef);
                                const longitude = convertDMSToDD(lon[0], lon[1], lon[2], lonRef);

                                // Create camera icon for photo marker
                                const photoIcon = L.divIcon({
                                    html: 'ðŸ“·',
                                    iconSize: [24, 24],
                                    className: 'photo-marker',
                                    iconAnchor: [12, 12]
                                });

                                // Add marker to map - clicking marker opens full-res photo
                                const marker = L.marker([latitude, longitude], { icon: photoIcon })
                                    .addTo(map)
                                    .on('click', function() {
                                        openPhotoModal(e.target.result, file.name, dateTime);
                                    });

                                // Create popup with photo thumbnail (clicking thumbnail also opens full-res)
                                const formattedDate = formatExifDate(dateTime);
                                const popupContent = `
                                    <div style="text-align: center; cursor: pointer;" onclick="openPhotoModal('${e.target.result}', '${file.name}', '${dateTime || ''}')">
                                        <img src="${e.target.result}" style="max-width: 200px; max-height: 200px; display: block; margin-bottom: 5px;">
                                        <div style="font-size: 11px; color: #666;">${file.name}</div>
                                        ${formattedDate ? `<div style="font-size: 10px; color: #999;">${formattedDate}</div>` : ''}
                                        <div style="font-size: 9px; color: #007bff; margin-top: 3px;">Click to view full size</div>
                                    </div>
                                `;
                                marker.bindPopup(popupContent);

                                photoMarkers.push(marker);
                                photosWithGPS++;
                            }

                            // Update status after all photos processed
                            if (photosProcessed === files.length) {
                                document.getElementById('photo-status').textContent =
                                    `Loaded ${photosWithGPS} of ${files.length} photos with GPS data`;
                            }
                        });
                    };
                };
                reader.readAsDataURL(file);
            });
        }

        // Add event listener for photo upload
        document.getElementById('photo-upload').addEventListener('change', handlePhotoUpload);

        // Initialize on page load
        window.addEventListener('load', initMap);
    </script>
</body>
</html>
