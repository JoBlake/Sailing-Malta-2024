<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sailing Track Visualizer</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #map {
            flex: 1;
            width: 100%;
        }

        .controls {
            background: white;
            padding: 15px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #speed-slider {
            width: 150px;
        }

        .info {
            font-size: 14px;
            color: #333;
        }

        .wind-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wind-arrow svg {
            display: block;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .legend {
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 12px;
            line-height: 1.5;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }

        .legend-scale {
            display: flex;
            height: 20px;
            margin: 5px 0;
            border: 1px solid #ccc;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .legend-note {
            margin-top: 5px;
            font-size: 10px;
            font-style: italic;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading tracks...</div>
    <div id="map"></div>

    <div class="controls">
        <button id="play-btn">Play</button>
        <button id="pause-btn" disabled>Pause</button>
        <button id="reset-btn">Reset</button>
        <button id="reverse-btn">Reverse</button>
        <button id="pan-btn">Pan</button>

        <div class="speed-control">
            <label for="speed-slider">Speed:</label>
            <input type="range" id="speed-slider" min="1" max="7" value="4" step="1" />
            <span id="speed-value">1x</span>
        </div>

        <div class="info">
            <span id="progress-info">Ready to play</span>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        let map;
        let tracks = [];
        let bounds = null;
        let twsRange = null;
        let allPoints = [];
        let currentIndex = 0;
        let animationInterval = null;
        let windMarker = null;
        let cogMarker = null;
        let awaMarker = null;
        let trackPolylines = [];
        let speed = 1;
        let panEnabled = false;
        let direction = 1; // 1 for forward, -1 for reverse
        let showWindArrow = true;
        let showCogArrow = true;
        let showAwaArrow = true;

        // Map slider values (1-7) to speed multipliers
        function getSpeedMultiplier(sliderValue) {
            const speedMap = {
                1: 0.125,  // 1/8x
                2: 0.25,   // 1/4x
                3: 0.5,    // 1/2x
                4: 1,      // 1x
                5: 2,      // 2x
                6: 4,      // 4x
                7: 8       // 8x
            };
            return speedMap[sliderValue] || 1;
        }

        // Get display label for speed
        function getSpeedLabel(sliderValue) {
            const labelMap = {
                1: '1/8x',
                2: '1/4x',
                3: '1/2x',
                4: '1x',
                5: '2x',
                6: '4x',
                7: '8x'
            };
            return labelMap[sliderValue] || '1x';
        }

        // Create wind arrow icon
        // twa: True Wind Angle (degrees)
        // tws: True Wind Speed
        // twsRange: {min, max} for normalization
        function createArrowIcon(tws, twa, twsRange) {
            // Calculate arrow length based on TWS (normalize to 40-80 pixels)
            const minLength = 40;
            const maxLength = 80;
            let length = minLength;

            if (twsRange && twsRange.max > twsRange.min) {
                const normalized = (tws - twsRange.min) / (twsRange.max - twsRange.min);
                length = minLength + normalized * (maxLength - minLength);
            } else if (tws > 0) {
                length = 60; // Default if no range
            }

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Create SVG arrow pointing upward (will be rotated away from TWA by adding 180 degrees)
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${twa + 180})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="blue" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="blue" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'wind-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Create COG arrow icon (Course Over Ground)
        // cog: Course Over Ground (degrees)
        // sog: Speed Over Ground (knots)
        function createCOGArrowIcon(sog, cog) {
            // Calculate arrow length based on SOG (normalize to 40-80 pixels)
            const minLength = 40;
            const maxLength = 80;
            // Assume SOG range 0-10 knots for scaling
            const normalized = Math.min(sog / 10, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Create SVG arrow pointing upward (will be rotated by COG)
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${cog})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="green" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="green" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'cog-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Create AWA arrow icon (Apparent Wind Angle)
        // awa: Apparent Wind Angle (degrees)
        // aws: Apparent Wind Speed (knots)
        function createAWAArrowIcon(aws, awa) {
            // Calculate arrow length based on AWS (normalize to 40-80 pixels)
            const minLength = 40;
            const maxLength = 80;
            // Assume AWS range 0-15 knots for scaling
            const normalized = Math.min(aws / 15, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Create SVG arrow pointing upward (will be rotated away from AWA by adding 180 degrees)
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${awa + 180})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="orange" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="orange" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'awa-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Initialize the map
        async function initMap() {
            try {
                // Fetch track data
                const response = await fetch('/api/tracks');
                const data = await response.json();
                tracks = data.tracks;
                bounds = data.bounds;
                twsRange = data.tws_range;

                // Hide loading indicator
                document.getElementById('loading').style.display = 'none';

                // Create map centered on the tracks
                if (bounds) {
                    map = L.map('map').setView(
                        [bounds.center_lat, bounds.center_lon],
                        13
                    );
                } else {
                    map = L.map('map').setView([38.92, 20.89], 13);
                }

                // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                // Draw all tracks on the map with line style based on RPM
                tracks.forEach((track, index) => {
                    // Draw segments: solid when rpm=0 (sailing), dotted when rpm>0 (motoring)
                    for (let i = 0; i < track.points.length - 1; i++) {
                        const p1 = track.points[i];
                        const p2 = track.points[i + 1];

                        // Determine line style based on RPM
                        let dashArray;
                        if (p1.rpm === 0 && p2.rpm === 0) {
                            dashArray = null; // Solid line for sailing
                        } else {
                            dashArray = '5, 10'; // Dotted line for motoring
                        }

                        const segment = L.polyline(
                            [[p1.lat, p1.lon], [p2.lat, p2.lon]],
                            {
                                color: 'blue',
                                weight: 3,
                                opacity: 0.7,
                                dashArray: dashArray
                            }
                        ).addTo(map);
                        trackPolylines.push(segment);
                    }

                    // Add start marker
                    if (track.points.length > 0) {
                        const start = track.points[0];
                        L.circleMarker([start.lat, start.lon], {
                            radius: 5,
                            color: 'green',
                            fillColor: 'green',
                            fillOpacity: 1
                        }).addTo(map).bindPopup(`Start: ${track.name}`);
                    }

                    // Add end marker
                    if (track.points.length > 0) {
                        const end = track.points[track.points.length - 1];
                        L.circleMarker([end.lat, end.lon], {
                            radius: 5,
                            color: 'red',
                            fillColor: 'red',
                            fillOpacity: 1
                        }).addTo(map).bindPopup(`End: ${track.name}`);
                    }

                    // Collect all points for animation
                    track.points.forEach(point => {
                        allPoints.push({
                            ...point,
                            trackName: track.name
                        });
                    });
                });

                // Sort all points chronologically by UTC timestamp
                allPoints.sort((a, b) => {
                    return new Date(a.utc) - new Date(b.utc);
                });

                // Fit map to bounds
                if (bounds) {
                    map.fitBounds([
                        [bounds.min_lat, bounds.min_lon],
                        [bounds.max_lat, bounds.max_lon]
                    ]);
                }

                // Add legend for arrows with checkboxes
                const legend = L.control({ position: 'bottomleft' });
                legend.onAdd = function(map) {
                    const div = L.DomUtil.create('div', 'legend');
                    div.innerHTML = `
                        <div class="legend-title">Arrow Legend</div>
                        <div style="margin-top: 5px;">
                            <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 3px;">
                                <input type="checkbox" id="toggle-wind" checked style="cursor: pointer;">
                                <svg width="35" height="20" xmlns="http://www.w3.org/2000/svg">
                                    <line x1="5" y1="10" x2="25" y2="10" stroke="blue" stroke-width="3"/>
                                    <path d="M 25,10 L 20,7 L 22,10 L 20,13 Z" fill="blue" stroke="blue" stroke-width="1"/>
                                </svg>
                                <span style="font-size: 11px;">Wind (TWA/TWS)</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 3px;">
                                <input type="checkbox" id="toggle-cog" checked style="cursor: pointer;">
                                <svg width="35" height="20" xmlns="http://www.w3.org/2000/svg">
                                    <line x1="5" y1="10" x2="21" y2="10" stroke="green" stroke-width="3"/>
                                    <path d="M 28,10 L 21,7 L 21,13 Z" fill="green" stroke="green" stroke-width="1"/>
                                </svg>
                                <span style="font-size: 11px;">Boat (COG/SOG)</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <input type="checkbox" id="toggle-awa" checked style="cursor: pointer;">
                                <svg width="35" height="20" xmlns="http://www.w3.org/2000/svg">
                                    <line x1="5" y1="10" x2="21" y2="10" stroke="orange" stroke-width="3"/>
                                    <path d="M 28,10 L 21,7 L 21,13 Z" fill="orange" stroke="orange" stroke-width="1"/>
                                </svg>
                                <span style="font-size: 11px;">Apparent Wind (AWA/AWS)</span>
                            </div>
                        </div>
                    `;

                    // Prevent clicks on the legend from propagating to the map
                    L.DomEvent.disableClickPropagation(div);

                    return div;
                };
                legend.addTo(map);

                // Add event listeners for arrow toggles
                setTimeout(() => {
                    document.getElementById('toggle-wind').addEventListener('change', (e) => {
                        showWindArrow = e.target.checked;
                        if (showWindArrow) {
                            windMarker.addTo(map);
                        } else {
                            map.removeLayer(windMarker);
                        }
                    });

                    document.getElementById('toggle-cog').addEventListener('change', (e) => {
                        showCogArrow = e.target.checked;
                        if (showCogArrow) {
                            cogMarker.addTo(map);
                        } else {
                            map.removeLayer(cogMarker);
                        }
                    });

                    document.getElementById('toggle-awa').addEventListener('change', (e) => {
                        showAwaArrow = e.target.checked;
                        if (showAwaArrow) {
                            awaMarker.addTo(map);
                        } else {
                            map.removeLayer(awaMarker);
                        }
                    });
                }, 100);

                // Create wind arrow marker (blue)
                if (allPoints.length > 0) {
                    const firstPoint = allPoints[0];
                    const windArrowIcon = createArrowIcon(firstPoint.tws, firstPoint.twa, twsRange);
                    windMarker = L.marker(
                        [firstPoint.lat, firstPoint.lon],
                        { icon: windArrowIcon }
                    ).addTo(map);

                    // Create COG arrow marker (green)
                    const cogArrowIcon = createCOGArrowIcon(firstPoint.sog, firstPoint.cog);
                    cogMarker = L.marker(
                        [firstPoint.lat, firstPoint.lon],
                        { icon: cogArrowIcon }
                    ).addTo(map);

                    // Create AWA arrow marker (orange)
                    const awaArrowIcon = createAWAArrowIcon(firstPoint.aws, firstPoint.awa);
                    awaMarker = L.marker(
                        [firstPoint.lat, firstPoint.lon],
                        { icon: awaArrowIcon }
                    ).addTo(map);
                }

                // No animation polyline - boat marker only to preserve original track visibility

            } catch (error) {
                console.error('Error loading tracks:', error);
                document.getElementById('loading').textContent = 'Error loading tracks!';
            }
        }

        // CMRmap colormap (Color Map for Remote sensing)
        // Maps a value from 0-1 to a color: Black -> Red -> Magenta -> Blue -> White
        function getColorFromValue(value) {
            // Clamp value between 0 and 1
            value = Math.max(0, Math.min(1, value));

            // CMRmap: Black -> Red -> Magenta -> Blue -> White
            if (value < 0.25) {
                // Black to Red
                const t = value / 0.25;
                const r = Math.floor(t * 255);
                const g = 0;
                const b = 0;
                return `rgb(${r}, ${g}, ${b})`;
            } else if (value < 0.5) {
                // Red to Magenta
                const t = (value - 0.25) / 0.25;
                const r = 255;
                const g = 0;
                const b = Math.floor(t * 255);
                return `rgb(${r}, ${g}, ${b})`;
            } else if (value < 0.75) {
                // Magenta to Blue
                const t = (value - 0.5) / 0.25;
                const r = Math.floor(255 * (1 - t));
                const g = 0;
                const b = 255;
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // Blue to White
                const t = (value - 0.75) / 0.25;
                const r = Math.floor(t * 255);
                const g = Math.floor(t * 255);
                const b = 255;
                return `rgb(${r}, ${g}, ${b})`;
            }
        }

        // Get color based on tws value
        function getTwsColor(tws) {
            if (!twsRange || twsRange.min === twsRange.max) {
                return 'black';
            }

            // Normalize tws to 0-1 range
            const normalized = (tws - twsRange.min) / (twsRange.max - twsRange.min);
            return getColorFromValue(normalized);
        }

        // Animation functions
        function startAnimation() {
            if (animationInterval) return;

            document.getElementById('play-btn').disabled = true;
            document.getElementById('pause-btn').disabled = false;

            const baseDelay = 50; // Base delay in milliseconds
            const delay = baseDelay / speed;

            animationInterval = setInterval(() => {
                // Check bounds based on direction
                if (direction === 1 && currentIndex >= allPoints.length) {
                    stopAnimation();
                    return;
                }
                if (direction === -1 && currentIndex < 0) {
                    stopAnimation();
                    return;
                }

                const point = allPoints[currentIndex];

                // Update wind arrow position and icon (blue)
                windMarker.setLatLng([point.lat, point.lon]);
                const newWindArrowIcon = createArrowIcon(point.tws, point.twa, twsRange);
                windMarker.setIcon(newWindArrowIcon);

                // Update COG arrow position and icon (green)
                cogMarker.setLatLng([point.lat, point.lon]);
                const newCOGArrowIcon = createCOGArrowIcon(point.sog, point.cog);
                cogMarker.setIcon(newCOGArrowIcon);

                // Update AWA arrow position and icon (orange)
                awaMarker.setLatLng([point.lat, point.lon]);
                const newAWAArrowIcon = createAWAArrowIcon(point.aws, point.awa);
                awaMarker.setIcon(newAWAArrowIcon);

                // Pan map to center on current position if enabled
                if (panEnabled) {
                    map.panTo([point.lat, point.lon]);
                }

                // Update info
                const progress = ((currentIndex / allPoints.length) * 100).toFixed(1);
                document.getElementById('progress-info').textContent =
                    `Time: ${point.utc} | Lat: ${point.lat.toFixed(6)} | Lon: ${point.lon.toFixed(6)} | RPM: ${point.rpm} | COG: ${point.cog.toFixed(1)}° SOG: ${point.sog.toFixed(2)}kt | TWA: ${point.twa.toFixed(1)}° TWS: ${point.tws.toFixed(1)}kt | AWA: ${point.awa.toFixed(1)}° AWS: ${point.aws.toFixed(2)}kt`;

                currentIndex += direction;
            }, delay);
        }

        function pauseAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
                document.getElementById('play-btn').disabled = false;
                document.getElementById('pause-btn').disabled = true;
            }
        }

        function stopAnimation() {
            pauseAnimation();
            document.getElementById('progress-info').textContent = 'Animation complete!';
        }

        function resetAnimation() {
            pauseAnimation();
            currentIndex = 0;
            direction = 1;

            // Reset Reverse button appearance
            const reverseBtn = document.getElementById('reverse-btn');
            reverseBtn.style.background = '#007bff';
            reverseBtn.textContent = 'Reverse';

            if (allPoints.length > 0) {
                windMarker.setLatLng([allPoints[0].lat, allPoints[0].lon]);
                cogMarker.setLatLng([allPoints[0].lat, allPoints[0].lon]);
                awaMarker.setLatLng([allPoints[0].lat, allPoints[0].lon]);
            }

            document.getElementById('progress-info').textContent = 'Ready to play';
            document.getElementById('play-btn').disabled = false;
        }

        // Event listeners
        document.getElementById('play-btn').addEventListener('click', startAnimation);
        document.getElementById('pause-btn').addEventListener('click', pauseAnimation);
        document.getElementById('reset-btn').addEventListener('click', resetAnimation);

        document.getElementById('pan-btn').addEventListener('click', () => {
            panEnabled = !panEnabled;
            const btn = document.getElementById('pan-btn');
            if (panEnabled) {
                btn.style.background = '#28a745';
                btn.textContent = 'Pan: ON';
            } else {
                btn.style.background = '#007bff';
                btn.textContent = 'Pan';
            }
        });

        document.getElementById('reverse-btn').addEventListener('click', () => {
            direction = -direction;
            const btn = document.getElementById('reverse-btn');
            if (direction === -1) {
                btn.style.background = '#ffc107';
                btn.textContent = 'Reverse: ON';
            } else {
                btn.style.background = '#007bff';
                btn.textContent = 'Reverse';
            }

            // Restart animation with new direction if currently playing
            if (animationInterval) {
                pauseAnimation();
                startAnimation();
            }
        });

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);
            speed = getSpeedMultiplier(sliderValue);
            document.getElementById('speed-value').textContent = getSpeedLabel(sliderValue);

            // Restart animation with new speed if currently playing
            if (animationInterval) {
                pauseAnimation();
                startAnimation();
            }
        });

        // Initialize on page load
        window.addEventListener('load', initMap);
    </script>
</body>
</html>
