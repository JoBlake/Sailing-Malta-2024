<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sailing Track Visualizer</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        #map {
            flex: 1;
        }

        .right-sidebar {
            width: 280px;
            min-width: 200px;
            max-width: 600px;
            background: white;
            border-left: 2px solid #ddd;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .resize-handle {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
            background: transparent;
            z-index: 1000;
            transition: background 0.2s;
        }

        .resize-handle:hover {
            background: rgba(0, 123, 255, 0.3);
        }

        .resize-handle:active {
            background: rgba(0, 123, 255, 0.5);
        }

        .tabs {
            display: flex;
            background: #f5f5f5;
            border-bottom: 2px solid #ddd;
        }

        .tab-button {
            flex: 1;
            padding: 12px;
            background: #f5f5f5;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }

        .tab-button:hover {
            background: #e0e0e0;
            color: #333;
        }

        .tab-button.active {
            background: white;
            color: #007bff;
            border-bottom-color: #007bff;
        }

        .tab-content {
            display: none;
            padding: 15px;
            flex: 1;
            overflow-y: auto;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .controls {
            background: white;
            padding: 15px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #speed-slider {
            width: 150px;
        }

        .info {
            font-size: 12px;
            color: #333;
            flex: 1;
            min-width: 200px;
        }

        .wind-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wind-arrow svg {
            display: block;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 500px;
        }

        .prompt-dialog {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 600px;
            margin: 0 auto;
        }

        .prompt-dialog h2 {
            margin-top: 0;
            color: #007bff;
            font-size: 24px;
        }

        .prompt-dialog p {
            color: #666;
            margin: 15px 0;
            line-height: 1.6;
        }

        .prompt-dialog input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin: 10px 0;
            box-sizing: border-box;
        }

        .prompt-dialog input:focus {
            border-color: #007bff;
            outline: none;
        }

        .prompt-dialog button {
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
        }

        .prompt-dialog button:hover {
            background: #0056b3;
        }

        .prompt-dialog .example {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            margin: 10px 0;
            border-left: 3px solid #007bff;
        }

        .legend {
            font-size: 12px;
            line-height: 1.5;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
        }

        .data-panel {
            font-size: 11px;
        }

        .data-panel-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 2px solid #28a745;
            padding-bottom: 5px;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }

        .data-label {
            font-weight: 600;
            color: #555;
        }

        .data-value {
            color: #000;
            font-family: monospace;
        }

        .legend-scale {
            display: flex;
            height: 20px;
            margin: 5px 0;
            border: 1px solid #ccc;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .legend-note {
            margin-top: 5px;
            font-size: 10px;
            font-style: italic;
            color: #666;
        }

        .boat-marker {
            font-size: 32px;
            text-align: center;
            filter: drop-shadow(3px 3px 3px rgba(0,0,0,0.4));
            cursor: pointer;
        }

        .photo-marker {
            font-size: 24px;
            text-align: center;
            cursor: pointer;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));
        }

        .photo-marker:hover {
            transform: scale(1.2);
        }

        .video-marker {
            font-size: 24px;
            text-align: center;
            cursor: pointer;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));
        }

        .video-marker:hover {
            transform: scale(1.2);
        }

        .photo-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            right: 280px; /* Leave space for right sidebar */
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            overflow: auto;
        }

        .photo-modal-content {
            margin: auto;
            display: block;
            max-width: 90%;
            max-height: 90%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #modal-video {
            background: #000;
        }

        .photo-modal-close {
            position: absolute;
            top: 20px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 2001;
        }

        .photo-modal-close:hover,
        .photo-modal-close:focus {
            color: #bbb;
        }

        .photo-modal-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
        }

        .annotation-marker {
            font-size: 24px;
            text-align: center;
            cursor: pointer;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));
        }

        .annotation-marker:hover {
            transform: scale(1.2);
        }

        .annotation-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .annotation-form textarea {
            width: 100%;
            min-height: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            font-family: Arial, sans-serif;
            resize: vertical;
        }

        .annotation-form button {
            padding: 8px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .annotation-form button:hover {
            background: #218838;
        }

        .annotation-list {
            max-height: 300px;
            overflow-y: auto;
            font-size: 11px;
        }

        .annotation-item {
            padding: 8px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-left: 3px solid #007bff;
            cursor: pointer;
        }

        .annotation-item:hover {
            background: #e9ecef;
        }

        .annotation-item-time {
            font-size: 10px;
            color: #666;
            margin-bottom: 4px;
        }

        .annotation-item-text {
            color: #333;
        }

        .distance-display {
            background: #e7f3ff;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .distance-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }

        .distance-label {
            font-weight: 600;
            color: #555;
            font-size: 11px;
        }

        .distance-value {
            color: #007bff;
            font-family: monospace;
            font-weight: bold;
            font-size: 11px;
        }

        /* Mobile Responsive Styles */
        @media screen and (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .right-sidebar {
                width: 100% !important;
                max-height: 40vh;
                border-left: none;
                border-top: 2px solid #ddd;
            }

            .resize-handle {
                display: none;
            }

            #map {
                height: 60vh;
            }

            .controls {
                font-size: 12px;
                padding: 10px;
            }

            button {
                padding: 8px 12px;
                font-size: 12px;
            }

            .speed-control {
                width: 100%;
            }

            #speed-slider {
                width: 100px;
            }

            .info {
                min-width: 100%;
                margin-top: 5px;
            }

            .photo-modal {
                right: 0;
            }

            .tab-button {
                font-size: 11px;
                padding: 10px 5px;
            }
        }

        @media screen and (max-width: 480px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .speed-control {
                justify-content: space-between;
            }

            button {
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading tracks...</div>

    <!-- Photo/Video Modal -->
    <div id="photo-modal" class="photo-modal">
        <span class="photo-modal-close" onclick="closePhotoModal()">&times;</span>
        <img class="photo-modal-content" id="modal-image" style="display: none;">
        <video class="photo-modal-content" id="modal-video" controls style="display: none;">
            <source id="modal-video-source" src="" type="">
            Your browser does not support the video tag.
        </video>
        <div class="photo-modal-info" id="modal-info"></div>
    </div>

    <div class="main-content">
        <div id="map"></div>

        <div class="right-sidebar" id="right-sidebar">
            <!-- Resize handle -->
            <div class="resize-handle" id="resize-handle"></div>

            <!-- Tab buttons -->
            <div class="tabs">
                <button class="tab-button active" onclick="switchTab('home')">Home</button>
                <button class="tab-button" onclick="switchTab('photo')">Photo</button>
                <button class="tab-button" onclick="switchTab('annotation')">Annotation</button>
            </div>

            <!-- Home Tab -->
            <div id="home-tab" class="tab-content active">
                <div class="data-panel">
                    <div class="data-panel-title">Track Directory</div>
                    <div style="font-size: 11px;">
                        <div style="display: flex; gap: 5px; margin-bottom: 8px;">
                            <input type="text" id="track-directory" placeholder="Enter directory path"
                                   style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px;">
                            <label for="folder-picker" style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; white-space: nowrap;">
                                üìÅ Browse Files
                                <input type="file" id="folder-picker" multiple accept=".json,.gpx" style="display: none;" onchange="handleFileSelect(event)">
                            </label>
                        </div>
                        <button onclick="updateTrackDirectory()" style="width: 100%; padding: 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            Load Tracks from Directory
                        </button>
                        <div id="directory-status" style="font-size: 10px; color: #666; margin-top: 5px; text-align: center;">Current: .</div>
                    </div>
                </div>

                <div class="legend">
                    <div class="legend-title">Legend</div>
                    <div style="margin-top: 5px;">
                        <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #555;">Arrows:</div>
                        <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 8px;">
                            <input type="checkbox" id="toggle-wind" checked style="cursor: pointer;">
                            <svg width="30" height="16" xmlns="http://www.w3.org/2000/svg">
                                <line x1="3" y1="8" x2="20" y2="8" stroke="blue" stroke-width="3"/>
                                <path d="M 20,8 L 15,5 L 17,8 L 15,11 Z" fill="blue"/>
                            </svg>
                            <span style="font-size: 11px;">True Wind (TWA/TWS)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 8px;">
                            <input type="checkbox" id="toggle-cog" checked style="cursor: pointer;">
                            <svg width="30" height="16" xmlns="http://www.w3.org/2000/svg">
                                <line x1="3" y1="8" x2="20" y2="8" stroke="green" stroke-width="3"/>
                                <path d="M 20,8 L 15,5 L 17,8 L 15,11 Z" fill="green"/>
                            </svg>
                            <span style="font-size: 11px;">Boat (COG/SOG)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 15px;">
                            <input type="checkbox" id="toggle-awa" checked style="cursor: pointer;">
                            <svg width="30" height="16" xmlns="http://www.w3.org/2000/svg">
                                <line x1="3" y1="8" x2="20" y2="8" stroke="orange" stroke-width="3"/>
                                <path d="M 20,8 L 15,5 L 17,8 L 15,11 Z" fill="orange"/>
                            </svg>
                            <span style="font-size: 11px;">Apparent Wind (AWA/AWS)</span>
                        </div>

                        <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #555;">Track Lines:</div>
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                            <svg width="40" height="16" xmlns="http://www.w3.org/2000/svg">
                                <line x1="3" y1="8" x2="37" y2="8" stroke="blue" stroke-width="3"/>
                            </svg>
                            <span style="font-size: 11px;">Sailing (RPM=0)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                            <svg width="40" height="16" xmlns="http://www.w3.org/2000/svg">
                                <line x1="3" y1="8" x2="37" y2="8" stroke="red" stroke-width="3"/>
                            </svg>
                            <span style="font-size: 11px;">Motoring (RPM>0)</span>
                        </div>
                    </div>
                </div>

                <div class="distance-display">
                    <div style="font-weight: bold; margin-bottom: 8px; font-size: 12px; color: #007bff;">Distance Travelled</div>
                    <div class="distance-row">
                        <span class="distance-label">Nautical Miles:</span>
                        <span class="distance-value" id="distance-nm">0.00 nm</span>
                    </div>
                    <div class="distance-row">
                        <span class="distance-label">Kilometers:</span>
                        <span class="distance-value" id="distance-km">0.00 km</span>
                    </div>
                </div>

                <div class="data-panel">
                    <div class="data-panel-title">Current Data</div>
                    <div id="data-display">
                        <div class="data-row"><span class="data-label">Time:</span><span class="data-value" id="data-time">--</span></div>
                        <div class="data-row"><span class="data-label">Latitude:</span><span class="data-value" id="data-lat">--</span></div>
                        <div class="data-row"><span class="data-label">Longitude:</span><span class="data-value" id="data-lon">--</span></div>
                        <div class="data-row"><span class="data-label">RPM:</span><span class="data-value" id="data-rpm">--</span></div>
                        <div class="data-row"><span class="data-label">COG:</span><span class="data-value" id="data-cog">--</span></div>
                        <div class="data-row"><span class="data-label">SOG:</span><span class="data-value" id="data-sog">--</span></div>
                        <div class="data-row"><span class="data-label">TWA:</span><span class="data-value" id="data-twa">--</span></div>
                        <div class="data-row"><span class="data-label">TWS:</span><span class="data-value" id="data-tws">--</span></div>
                        <div class="data-row"><span class="data-label">AWA:</span><span class="data-value" id="data-awa">--</span></div>
                        <div class="data-row"><span class="data-label">AWS:</span><span class="data-value" id="data-aws">--</span></div>
                    </div>
                </div>

                <div class="data-panel">
                    <div class="data-panel-title">Position Control</div>
                    <div style="font-size: 11px; padding: 5px 0;">
                        <label for="position-slider" style="display: block; margin-bottom: 5px; font-weight: 600; color: #555;">Track Position:</label>
                        <input type="range" id="position-slider" min="0" max="100" value="0" style="width: 100%; cursor: pointer;">
                        <div id="position-info" style="font-size: 10px; color: #666; margin-top: 5px; text-align: center;">Point 0 of 0</div>
                    </div>
                </div>
            </div>

            <!-- Photo Tab -->
            <div id="photo-tab" class="tab-content">
                <div class="photo-panel">
                    <div class="data-panel-title">Photo & Video Gallery</div>
                    <div style="font-size: 11px;">
                        <label for="photo-upload" style="display: block; margin-bottom: 8px; cursor: pointer; padding: 8px; background: #007bff; color: white; text-align: center; border-radius: 4px;">
                            Select Photos & Videos
                            <input type="file" id="photo-upload" multiple accept="image/*,video/*,.mp4,.mov,.avi,.wmv,.flv,.mkv" style="display: none;">
                        </label>
                        <div style="margin-top: 10px; padding: 8px; background: #e7f3ff; border-radius: 4px;">
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 11px;">
                                <input type="checkbox" id="filter-photos-by-time" checked style="cursor: pointer;">
                                <span>Only show photos/videos taken during track time</span>
                            </label>
                        </div>
                        <div id="photo-status" style="font-size: 10px; color: #666; margin-top: 5px;">No photos or videos loaded</div>
                        <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 10px; color: #666;">
                            <strong>Instructions:</strong> Select photos and videos with GPS metadata. They will appear as camera üì∑ or video üé• icons on the map at their GPS coordinates. Click on the icons to view full-size.
                        </div>
                    </div>
                </div>
            </div>

            <!-- Annotation Tab -->
            <div id="annotation-tab" class="tab-content">
                <div class="annotation-panel">
                    <div class="data-panel-title">Add Annotation</div>
                    <div class="annotation-form">
                        <textarea id="annotation-text" placeholder="Enter annotation text for current position..."></textarea>
                        <button onclick="addAnnotation()">Add Annotation</button>
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 10px; color: #666;">
                        <strong>Note:</strong> Annotations are added at the current track position. Use the position slider in the Home tab to select where to add an annotation.
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <div class="data-panel-title">Manage Annotations</div>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button onclick="saveAnnotations()" style="flex: 1; padding: 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            Save Annotations
                        </button>
                        <label for="annotation-file-input" style="flex: 1; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; text-align: center;">
                            Load from File
                            <input type="file" id="annotation-file-input" accept=".json" style="display: none;" onchange="loadAnnotations(event)">
                        </label>
                    </div>
                    <div style="font-size: 10px; color: #666; margin-top: 5px;">
                        <strong>Save location:</strong> Saves as <code style="background: #e9ecef; padding: 2px 4px; border-radius: 2px;">sailing-annotations.json</code> in your track directory (or project root if directory doesn't exist). The success message will show the actual save location.
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <div class="data-panel-title">Annotations List</div>
                    <div id="annotations-list" class="annotation-list">
                        <div style="font-size: 11px; color: #999; text-align: center; padding: 20px;">No annotations yet</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button id="play-btn">Play</button>
        <button id="pause-btn" disabled>Pause</button>
        <button id="reset-btn">Reset</button>
        <button id="reverse-btn">Reverse</button>
        <button id="pan-btn">Pan</button>

        <div class="speed-control">
            <label for="speed-slider">Speed:</label>
            <input type="range" id="speed-slider" min="1" max="7" value="4" step="1" />
            <span id="speed-value">1x</span>
        </div>

        <div class="info">
            <span id="progress-info">Ready to play</span>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- EXIF.js for reading GPS data from photos -->
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>

    <script>
        let map;
        let tracks = [];
        let bounds = null;
        let allPoints = [];
        let currentIndex = 0;
        let animationInterval = null;
        let windMarker = null;
        let cogMarker = null;
        let awaMarker = null;
        let boatMarker = null; // Simple boat position marker for GPX files
        let trackPolylines = [];
        let speed = 1;
        let panEnabled = false;
        let direction = 1; // 1 for forward, -1 for reverse
        let showWindArrow = true;
        let showCogArrow = true;
        let showAwaArrow = true;
        let photoMarkers = [];
        let annotations = [];
        let annotationMarkers = [];
        let totalDistanceNM = 0;
        let totalDistanceKM = 0;
        let hasSailingData = false; // Flag to track if any loaded track has sailing data
        let isOverWater = true; // Flag to track if GPX track is over water (true) or land (false)

        // Check if coordinates are over water or land using Nominatim reverse geocoding
        async function checkIfOverWater(lat, lon) {
            try {
                // Use Nominatim reverse geocoding API
                const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10`;
                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'SailingTrackVisualizer/1.0'
                    }
                });

                if (!response.ok) {
                    console.warn('Nominatim API error, defaulting to water');
                    return true; // Default to water if API fails
                }

                const data = await response.json();

                console.log(`Checking (${lat}, ${lon}):`, data);

                // If there's an error in the response, it means no land feature found - likely water
                if (data.error) {
                    console.log('  -> No address found, assuming water');
                    return true;
                }

                // Check the OSM class - 'natural' water features
                const osmClass = data.class || '';
                const osmType = data.type || '';

                // Water-related OSM classes and types
                if (osmClass === 'natural' && ['water', 'bay', 'strait', 'sea'].includes(osmType)) {
                    console.log(`  -> Water feature detected: ${osmClass}/${osmType}`);
                    return true;
                }

                if (osmClass === 'waterway' || osmClass === 'water') {
                    console.log(`  -> Water feature detected: ${osmClass}`);
                    return true;
                }

                // Check for specific place types that indicate water
                const waterTypes = ['sea', 'ocean', 'bay', 'strait', 'channel', 'reef'];
                if (waterTypes.includes(osmType)) {
                    console.log(`  -> Water type detected: ${osmType}`);
                    return true;
                }

                // If we have detailed land features (road, building, etc.), it's definitely land
                const address = data.address || {};
                const hasDetailedLandFeatures = address.road || address.building ||
                                               address.house_number || address.village ||
                                               address.town || address.city ||
                                               address.county || address.municipality;

                if (hasDetailedLandFeatures) {
                    console.log('  -> Land features detected');
                    return false; // Definitely land
                }

                // If we only have country/state but no detailed features, could be over water
                // but Nominatim returned the nearest land
                const onlyBroadLocation = (address.country || address.state) && !hasDetailedLandFeatures;
                if (onlyBroadLocation) {
                    console.log('  -> Only broad location, assuming water');
                    return true;
                }

                // Default to land if we have any address
                console.log('  -> Has address, assuming land');
                return false;

            } catch (error) {
                console.warn('Error checking water/land, defaulting to water:', error);
                return true; // Default to water if check fails
            }
        }

        // Detect if track is primarily over water or land by sampling points
        async function detectTrackType(points) {
            if (!points || points.length === 0) {
                console.log('No points to check, defaulting to water');
                return true; // Default to water
            }

            // Sample up to 3 points: start, middle, end
            const sampleIndices = [];
            sampleIndices.push(0); // Start
            if (points.length > 2) {
                sampleIndices.push(Math.floor(points.length / 2)); // Middle
            }
            if (points.length > 1) {
                sampleIndices.push(points.length - 1); // End
            }

            console.log(`Sampling ${sampleIndices.length} points from ${points.length} total points`);

            let waterCount = 0;
            let landCount = 0;

            // Check each sample point with a delay to respect rate limits
            for (let i = 0; i < sampleIndices.length; i++) {
                const index = sampleIndices[i];
                const point = points[index];
                console.log(`\nChecking point ${i + 1}/${sampleIndices.length} (index ${index}): [${point.lat}, ${point.lon}]`);

                const isWater = await checkIfOverWater(point.lat, point.lon);

                if (isWater) {
                    waterCount++;
                    console.log(`  ‚úì Point classified as WATER (total water: ${waterCount})`);
                } else {
                    landCount++;
                    console.log(`  ‚úì Point classified as LAND (total land: ${landCount})`);
                }

                // Add delay between API calls to respect rate limits (1 second)
                if (i < sampleIndices.length - 1) {
                    console.log('  Waiting 1 second before next check...');
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            console.log(`\nDetection complete: ${waterCount} water, ${landCount} land`);
            // Return true if majority is water
            return waterCount >= landCount;
        }

        // Tab switching function
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
        }

        // Helper function to calculate distance between two lat/lon points (Haversine formula)
        // Returns distance in nautical miles
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3440.065; // Earth's radius in nautical miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Calculate distance from start to current position
        function calculateDistanceToCurrentPosition() {
            let distanceNM = 0;
            // Calculate distance from start (index 0) to current position
            for (let i = 1; i <= currentIndex && i < allPoints.length; i++) {
                const p1 = allPoints[i - 1];
                const p2 = allPoints[i];
                distanceNM += calculateDistance(p1.lat, p1.lon, p2.lat, p2.lon);
            }
            totalDistanceNM = distanceNM;
            totalDistanceKM = distanceNM * 1.852; // Convert to kilometers
            updateDistanceDisplay();
        }

        // Update distance display
        function updateDistanceDisplay() {
            document.getElementById('distance-nm').textContent = totalDistanceNM.toFixed(2) + ' nm';
            document.getElementById('distance-km').textContent = totalDistanceKM.toFixed(2) + ' km';
        }

        // Add annotation at current position
        function addAnnotation() {
            const text = document.getElementById('annotation-text').value.trim();
            if (!text) {
                alert('Please enter annotation text');
                return;
            }

            if (allPoints.length === 0 || currentIndex >= allPoints.length) {
                alert('No track position available');
                return;
            }

            const point = allPoints[currentIndex];
            const annotation = {
                text: text,
                lat: point.lat,
                lon: point.lon,
                timestamp: point.utc,
                index: currentIndex
            };

            annotations.push(annotation);

            // Add marker to map
            const annotationIcon = L.divIcon({
                html: 'üìù',
                iconSize: [24, 24],
                className: 'annotation-marker',
                iconAnchor: [12, 12]
            });

            const marker = L.marker([point.lat, point.lon], { icon: annotationIcon })
                .addTo(map)
                .on('click', function() {
                    showAnnotationPopup(annotation);
                });

            annotationMarkers.push(marker);

            // Clear textarea
            document.getElementById('annotation-text').value = '';

            // Update annotations list
            updateAnnotationsList();

            // Show success message
            alert('Annotation added successfully!');
        }

        // Show annotation popup
        function showAnnotationPopup(annotation) {
            const popup = L.popup()
                .setLatLng([annotation.lat, annotation.lon])
                .setContent(`
                    <div style="max-width: 200px;">
                        <div style="font-weight: bold; margin-bottom: 5px;">Annotation</div>
                        <div style="margin-bottom: 8px; white-space: pre-wrap;">${annotation.text}</div>
                        <div style="font-size: 10px; color: #666; border-top: 1px solid #ddd; padding-top: 5px;">
                            ${annotation.timestamp}
                        </div>
                    </div>
                `)
                .openOn(map);
        }

        // Update annotations list in UI
        function updateAnnotationsList() {
            const listContainer = document.getElementById('annotations-list');

            if (annotations.length === 0) {
                listContainer.innerHTML = '<div style="font-size: 11px; color: #999; text-align: center; padding: 20px;">No annotations yet</div>';
                return;
            }

            listContainer.innerHTML = annotations.map((annotation, index) => `
                <div class="annotation-item" onclick="jumpToAnnotation(${index})">
                    <div class="annotation-item-time">${annotation.timestamp}</div>
                    <div class="annotation-item-text">${annotation.text}</div>
                </div>
            `).join('');
        }

        // Jump to annotation position
        function jumpToAnnotation(index) {
            const annotation = annotations[index];

            // Pan map to annotation
            map.setView([annotation.lat, annotation.lon], map.getZoom());

            // Update current index and position
            currentIndex = annotation.index;

            // Update arrows and data display
            if (allPoints.length > 0 && currentIndex < allPoints.length) {
                const point = allPoints[currentIndex];

                // Update arrows (only if sailing data available)
                if (hasSailingData) {
                    windMarker.setLatLng([point.lat, point.lon]);
                    const newWindArrowIcon = createArrowIcon(point.tws || 0, point.twa || 0, point.cog || 0);
                    windMarker.setIcon(newWindArrowIcon);

                    cogMarker.setLatLng([point.lat, point.lon]);
                    const newCOGArrowIcon = createCOGArrowIcon(point.sog || 0, point.cog || 0);
                    cogMarker.setIcon(newCOGArrowIcon);

                    awaMarker.setLatLng([point.lat, point.lon]);
                    const newAWAArrowIcon = createAWAArrowIcon(point.aws || 0, point.awa || 0, point.cog || 0);
                    awaMarker.setIcon(newAWAArrowIcon);
                }

                updateDataDisplay(point);

                // Update distance from start to current position
                calculateDistanceToCurrentPosition();

                document.getElementById('position-slider').value = currentIndex;
                document.getElementById('position-info').textContent = `${point.utc} (${currentIndex + 1}/${allPoints.length})`;
            }

            // Show popup
            showAnnotationPopup(annotation);
        }

        // Save annotations to JSON file in track directory
        async function saveAnnotations() {
            if (annotations.length === 0) {
                alert('No annotations to save');
                return;
            }

            try {
                // Send annotations to server to save in track directory
                const response = await fetch('/api/annotations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ annotations: annotations })
                });

                const data = await response.json();

                if (data.status === 'success') {
                    alert(data.message);
                } else {
                    alert('Error saving annotations: ' + data.message);
                }
            } catch (error) {
                console.error('Error saving annotations:', error);
                alert('Error saving annotations: ' + error.message);
            }
        }

        // Load annotations from JSON file
        function loadAnnotations(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const loadedAnnotations = JSON.parse(e.target.result);

                    if (!Array.isArray(loadedAnnotations)) {
                        alert('Invalid annotation file format');
                        return;
                    }

                    // Clear existing annotations
                    annotationMarkers.forEach(marker => map.removeLayer(marker));
                    annotationMarkers = [];
                    annotations = [];

                    // Load new annotations
                    loadedAnnotations.forEach(annotation => {
                        // Validate annotation structure
                        if (annotation.text && annotation.lat && annotation.lon && annotation.timestamp !== undefined && annotation.index !== undefined) {
                            annotations.push(annotation);

                            // Add marker to map
                            const annotationIcon = L.divIcon({
                                html: 'üìù',
                                iconSize: [24, 24],
                                className: 'annotation-marker',
                                iconAnchor: [12, 12]
                            });

                            const marker = L.marker([annotation.lat, annotation.lon], { icon: annotationIcon })
                                .addTo(map)
                                .on('click', function() {
                                    showAnnotationPopup(annotation);
                                });

                            annotationMarkers.push(marker);
                        }
                    });

                    // Update annotations list
                    updateAnnotationsList();

                    alert(`Loaded ${annotations.length} annotation(s)`);

                    // Reset file input
                    event.target.value = '';

                } catch (error) {
                    alert('Error loading annotations: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Helper function to update data display
        function updateDataDisplay(point) {
            document.getElementById('data-time').textContent = point.utc || '--';
            document.getElementById('data-lat').textContent = point.lat ? point.lat.toFixed(6) + '¬∞' : '--';
            document.getElementById('data-lon').textContent = point.lon ? point.lon.toFixed(6) + '¬∞' : '--';

            // Check if this is estimated data (from GPX files)
            const isEstimated = point.estimated === true;

            // Show sailing data if available, or estimated values for GPX
            if (hasSailingData) {
                document.getElementById('data-rpm').textContent = point.rpm !== null ? point.rpm : '--';
                document.getElementById('data-cog').textContent = point.cog !== null ? point.cog.toFixed(1) + '¬∞' : '--';
                document.getElementById('data-sog').textContent = point.sog !== null ? point.sog.toFixed(2) + ' kt' : '--';
                document.getElementById('data-twa').textContent = point.twa !== null ? point.twa.toFixed(1) + '¬∞' : '--';
                document.getElementById('data-tws').textContent = point.tws !== null ? point.tws.toFixed(1) + ' kt' : '--';
                document.getElementById('data-awa').textContent = point.awa !== null ? point.awa.toFixed(1) + '¬∞' : '--';
                document.getElementById('data-aws').textContent = point.aws !== null ? point.aws.toFixed(2) + ' kt' : '--';
            } else if (isEstimated) {
                // For GPX files, show estimated SOG in km/hr and COG as bearing
                document.getElementById('data-cog').textContent = point.cog !== null ? point.cog.toFixed(1) + '¬∞ (est.)' : '--';
                // Convert knots to km/hr (1 knot = 1.852 km/hr)
                const sogKmh = point.sog !== null ? (point.sog * 1.852) : null;
                document.getElementById('data-sog').textContent = sogKmh !== null ? sogKmh.toFixed(2) + ' km/h (est.)' : '--';
            }
        }

        // Map slider values (1-7) to speed multipliers
        function getSpeedMultiplier(sliderValue) {
            const speedMap = {
                1: 0.125,  // 1/8x
                2: 0.25,   // 1/4x
                3: 0.5,    // 1/2x
                4: 1,      // 1x
                5: 2,      // 2x
                6: 4,      // 4x
                7: 8       // 8x
            };
            return speedMap[sliderValue] || 1;
        }

        // Get display label for speed
        function getSpeedLabel(sliderValue) {
            const labelMap = {
                1: '1/8x',
                2: '1/4x',
                3: '1/2x',
                4: '1x',
                5: '2x',
                6: '4x',
                7: '8x'
            };
            return labelMap[sliderValue] || '1x';
        }

        // Create wind arrow icon
        // tws: True Wind Speed
        // twa: True Wind Angle (degrees) - relative to boat heading
        // cog: Course Over Ground (degrees) - boat's heading/direction
        function createArrowIcon(tws, twa, cog) {
            // Calculate arrow length based on TWS with truly proportional scaling
            // Use unified scale: 0-20 knots for consistency across all arrows
            const minLength = 10; // Small minimum for visibility
            const maxLength = 80;
            const maxScale = 20; // Maximum knots for scaling
            const normalized = Math.min(tws / maxScale, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Calculate absolute wind direction (COG + TWA)
            const absoluteWindDirection = cog + twa;

            // Create SVG arrow pointing towards where the wind is coming from
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${absoluteWindDirection})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="blue" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="blue" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'wind-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Create COG arrow icon (Course Over Ground)
        // cog: Course Over Ground (degrees)
        // sog: Speed Over Ground (knots)
        function createCOGArrowIcon(sog, cog) {
            // Calculate arrow length based on SOG with truly proportional scaling
            // Use unified scale: 0-20 knots for consistency across all arrows
            const minLength = 10; // Small minimum for visibility
            const maxLength = 80;
            const maxScale = 20; // Maximum knots for scaling
            const normalized = Math.min(sog / maxScale, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Create SVG arrow pointing upward (will be rotated by COG)
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${cog})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="green" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="green" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'cog-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Create AWA arrow icon (Apparent Wind Angle)
        // aws: Apparent Wind Speed (knots)
        // awa: Apparent Wind Angle (degrees) - relative to boat heading
        // cog: Course Over Ground (degrees) - boat's heading/direction
        function createAWAArrowIcon(aws, awa, cog) {
            // Calculate arrow length based on AWS with truly proportional scaling
            // Use unified scale: 0-20 knots for consistency across all arrows
            const minLength = 10; // Small minimum for visibility
            const maxLength = 80;
            const maxScale = 20; // Maximum knots for scaling
            const normalized = Math.min(aws / maxScale, 1);
            const length = minLength + normalized * (maxLength - minLength);

            const lineWidth = 4;
            const arrowheadWidth = 14;
            const arrowheadLength = 18;

            // Calculate absolute apparent wind direction (COG + AWA)
            const absoluteApparentWindDirection = cog + awa;

            // Create SVG arrow pointing towards where the apparent wind is coming from
            const svg = `
                <svg width="${length + 30}" height="${length + 30}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${(length + 30) / 2}, ${(length + 30) / 2}) rotate(${absoluteApparentWindDirection})">
                        <!-- Arrow shaft -->
                        <line x1="0" y1="5" x2="0" y2="${-length + arrowheadLength}"
                              stroke="orange" stroke-width="${lineWidth}" stroke-linecap="butt"/>
                        <!-- Arrowhead - solid triangle -->
                        <polygon points="0,${-length} ${-arrowheadWidth/2},${-length + arrowheadLength} ${arrowheadWidth/2},${-length + arrowheadLength}"
                                 fill="orange" stroke="none"/>
                    </g>
                </svg>
            `;

            return L.divIcon({
                className: 'awa-arrow',
                html: svg,
                iconSize: [length + 30, length + 30],
                iconAnchor: [(length + 30) / 2, (length + 30) / 2]
            });
        }

        // Load tracks from prompt dialog
        async function loadTracksFromPrompt() {
            const directoryInput = document.getElementById('prompt-directory');
            const directory = directoryInput.value.trim() || '.';

            try {
                // Save the new directory configuration
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ track_directory: directory })
                });

                if (!response.ok) {
                    throw new Error('Failed to update configuration');
                }

                // Show loading message
                document.getElementById('loading').innerHTML = '<div style="padding: 40px; text-align: center;"><h2>Loading tracks...</h2><p>Please wait...</p></div>';

                // Reload the page to refresh everything
                location.reload();

            } catch (error) {
                console.error('Error updating directory:', error);
                alert('Error updating directory: ' + error.message);
            }
        }

        // Handle file selection from file browser (for prompt dialog)
        async function handlePromptFileSelect(event) {
            const files = event.target.files;
            if (files.length > 0) {
                await uploadAndLoadFiles(files);
            }
        }

        // Handle file selection from file browser (for Home tab)
        async function handleFileSelect(event) {
            const files = event.target.files;
            if (files.length > 0) {
                await uploadAndLoadFiles(files);
            }
        }

        // Upload files and load tracks directly
        async function uploadAndLoadFiles(files) {
            try {
                // Show loading message
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').textContent = `Uploading and processing ${files.length} file(s)...`;

                // Create FormData to upload files
                const formData = new FormData();
                for (let file of files) {
                    formData.append('files', file);
                }

                // Upload files to server
                const response = await fetch('/api/upload-files', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.status === 'success') {
                    // Reload the page and let initMap handle the uploaded tracks
                    // Store the data temporarily
                    sessionStorage.setItem('uploadedTracks', JSON.stringify(data));
                    location.reload();
                } else {
                    alert('Error loading files: ' + data.message);
                    document.getElementById('loading').style.display = 'none';
                }
            } catch (error) {
                console.error('Error uploading files:', error);
                alert('Error uploading files: ' + error.message);
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Update track directory configuration from Home tab
        async function updateTrackDirectory() {
            const directoryInput = document.getElementById('track-directory');
            const directory = directoryInput.value.trim() || '.';

            try {
                // Save the new directory configuration
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ track_directory: directory })
                });

                if (!response.ok) {
                    throw new Error('Failed to update configuration');
                }

                // Update status
                document.getElementById('directory-status').textContent = `Current: ${directory}`;

                // Show loading message
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').textContent = 'Loading tracks from new directory...';

                // Reload the page to refresh everything
                location.reload();

            } catch (error) {
                console.error('Error updating directory:', error);
                alert('Error updating directory: ' + error.message);
            }
        }

        // Auto-load annotations if available
        async function autoLoadAnnotations() {
            try {
                const response = await fetch('/api/annotations');
                const data = await response.json();

                if (data.status === 'success' && Array.isArray(data.annotations)) {
                    // Clear existing annotations
                    annotationMarkers.forEach(marker => map.removeLayer(marker));
                    annotationMarkers = [];
                    annotations = [];

                    // Load annotations from server
                    data.annotations.forEach(annotation => {
                        if (annotation.text && annotation.lat && annotation.lon && annotation.timestamp !== undefined && annotation.index !== undefined) {
                            annotations.push(annotation);

                            // Add marker to map
                            const annotationIcon = L.divIcon({
                                html: 'üìù',
                                iconSize: [24, 24],
                                className: 'annotation-marker',
                                iconAnchor: [12, 12]
                            });

                            const marker = L.marker([annotation.lat, annotation.lon], { icon: annotationIcon })
                                .addTo(map)
                                .on('click', function() {
                                    showAnnotationPopup(annotation);
                                });

                            annotationMarkers.push(marker);
                        }
                    });

                    // Update annotations list
                    updateAnnotationsList();

                    if (annotations.length > 0) {
                        console.log(`Auto-loaded ${annotations.length} annotation(s) from ${data.file || 'server'}`);
                    } else {
                        console.log(`Annotations initialized: ${data.message || 'No annotations found, starting with empty list'}`);
                    }
                } else if (data.status === 'not_found') {
                    // Legacy handling - should not be reached with new backend code
                    console.log('No annotation file found in track directory');
                    annotations = [];
                    updateAnnotationsList();
                } else if (data.status === 'error') {
                    console.error('Error loading annotations:', data.message);
                }
            } catch (error) {
                console.error('Error auto-loading annotations:', error);
            }
        }

        // Initialize the map
        async function initMap() {
            try {
                // Load current configuration
                const configResponse = await fetch('/api/config');
                const config = await configResponse.json();
                const currentDirectory = config.track_directory || '.';

                // Update directory input and status
                document.getElementById('track-directory').value = currentDirectory;
                document.getElementById('directory-status').textContent = `Current: ${currentDirectory}`;

                // Check if we have uploaded tracks in sessionStorage
                const uploadedTracksData = sessionStorage.getItem('uploadedTracks');
                let data;
                let isUploadedTracks = false;

                if (uploadedTracksData) {
                    // Use uploaded tracks
                    data = JSON.parse(uploadedTracksData);
                    isUploadedTracks = true;
                    // Clear sessionStorage after using
                    sessionStorage.removeItem('uploadedTracks');
                } else {
                    // Fetch track data from directory
                    const response = await fetch('/api/tracks');
                    data = await response.json();
                }

                tracks = data.tracks;
                bounds = data.bounds;

                // Check if we have any tracks
                if (tracks.length === 0) {
                    document.getElementById('loading').innerHTML = `
                        <div class="prompt-dialog">
                            <h2>üìÇ Welcome to Sailing Track Visualizer</h2>
                            <p>To get started, please enter the location of your tracking files.</p>
                            <div class="example">
                                <strong>Examples:</strong><br>
                                Current directory: .<br>
                                Windows: C:\\Users\\username\\Documents\\tracks<br>
                                Or: C:/Users/username/Documents/tracks<br>
                                Linux/Mac: /home/username/tracks
                            </div>
                            <div style="display: flex; gap: 10px; margin: 15px 0;">
                                <input type="text" id="prompt-directory" placeholder="Enter directory path..." value="${currentDirectory}" style="flex: 1;">
                                <label for="prompt-folder-picker" style="padding: 12px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; white-space: nowrap;">
                                    üìÅ Browse Files
                                    <input type="file" id="prompt-folder-picker" multiple accept=".json,.gpx" style="display: none;" onchange="handlePromptFileSelect(event)">
                                </label>
                            </div>
                            <button onclick="loadTracksFromPrompt()">Load Tracks</button>
                            <p style="margin-top: 20px; font-size: 12px; color: #999;">
                                Supported formats: JSON (export *.json) and GPX (*.gpx)
                            </p>
                        </div>
                    `;
                    return; // Don't initialize the map if there are no tracks
                }

                // Check if any track has sailing data
                hasSailingData = tracks.some(track => track.has_sailing_data);

                // Hide loading indicator temporarily
                document.getElementById('loading').style.display = 'none';

                // Create map centered on the tracks
                if (bounds) {
                    map = L.map('map').setView(
                        [bounds.center_lat, bounds.center_lon],
                        13
                    );
                } else {
                    map = L.map('map').setView([38.92, 20.89], 13);
                }

                // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                // Draw all tracks on the map with line style based on RPM
                tracks.forEach((track, index) => {
                    // Draw segments
                    for (let i = 0; i < track.points.length - 1; i++) {
                        const p1 = track.points[i];
                        const p2 = track.points[i + 1];

                        // Determine color based on whether sailing data is available
                        let segmentColor;
                        if (track.has_sailing_data) {
                            // If sailing data available: blue when rpm=0 (sailing), red when rpm>0 (motoring)
                            if (p1.rpm === 0 && p2.rpm === 0) {
                                segmentColor = 'blue'; // Blue for sailing
                            } else {
                                segmentColor = 'red'; // Red for motoring
                            }
                        } else {
                            // If only tracking data available: solid blue
                            segmentColor = 'blue';
                        }

                        const segment = L.polyline(
                            [[p1.lat, p1.lon], [p2.lat, p2.lon]],
                            {
                                color: segmentColor,
                                weight: 2,
                                opacity: 0.7
                            }
                        ).addTo(map);
                        trackPolylines.push(segment);
                    }

                    // Add start marker
                    if (track.points.length > 0) {
                        const start = track.points[0];
                        L.circleMarker([start.lat, start.lon], {
                            radius: 5,
                            color: 'green',
                            fillColor: 'green',
                            fillOpacity: 1
                        }).addTo(map).bindPopup(`Start: ${track.name}`);
                    }

                    // Add end marker
                    if (track.points.length > 0) {
                        const end = track.points[track.points.length - 1];
                        L.circleMarker([end.lat, end.lon], {
                            radius: 5,
                            color: 'red',
                            fillColor: 'red',
                            fillOpacity: 1
                        }).addTo(map).bindPopup(`End: ${track.name}`);
                    }

                    // Collect all points for animation
                    track.points.forEach(point => {
                        allPoints.push({
                            ...point,
                            trackName: track.name
                        });
                    });
                });

                // Sort all points chronologically by UTC timestamp
                allPoints.sort((a, b) => {
                    return new Date(a.utc) - new Date(b.utc);
                });

                console.log(`=== Track Detection ===`);
                console.log(`Number of tracks: ${tracks.length}`);
                console.log(`Has sailing data: ${hasSailingData}`);
                console.log(`All points count: ${allPoints.length}`);

                // For GPX tracks (no sailing data), detect if over water or land
                if (!hasSailingData && allPoints.length > 0) {
                    console.log('Starting land/water detection...');
                    document.getElementById('loading').style.display = 'block';
                    document.getElementById('loading').textContent = 'Detecting track type (water/land)...';
                    isOverWater = await detectTrackType(allPoints);
                    console.log(`=== Final Result: Track detected as ${isOverWater ? 'WATER ‚õµ' : 'LAND üö∂'} ===`);
                    document.getElementById('loading').style.display = 'none';
                } else {
                    if (hasSailingData) {
                        console.log('Skipping land/water detection - sailing data available (JSON files)');
                    } else {
                        console.log('Skipping land/water detection - no points available');
                    }
                }

                // Calculate initial distance (at start position)
                calculateDistanceToCurrentPosition();

                // Fit map to bounds
                if (bounds) {
                    map.fitBounds([
                        [bounds.min_lat, bounds.min_lon],
                        [bounds.max_lat, bounds.max_lon]
                    ]);
                }

                // Hide or show UI elements based on sailing data availability
                if (!hasSailingData) {
                    // Hide arrow legend items
                    const arrowLegend = document.querySelector('.legend div:nth-child(2)');
                    if (arrowLegend) arrowLegend.style.display = 'none';

                    // Hide sailing-specific data rows in data panel (keep SOG and COG for GPX)
                    const sailingOnlyRows = ['rpm', 'twa', 'tws', 'awa', 'aws'];
                    sailingOnlyRows.forEach(id => {
                        const row = document.getElementById(`data-${id}`)?.parentElement;
                        if (row) row.style.display = 'none';
                    });

                    // Make sure SOG and COG are visible for GPX files with estimated values
                    ['sog', 'cog'].forEach(id => {
                        const row = document.getElementById(`data-${id}`)?.parentElement;
                        if (row) row.style.display = '';
                    });
                }

                // Add event listeners for arrow toggles (only if sailing data available)
                if (hasSailingData) {
                    document.getElementById('toggle-wind').addEventListener('change', (e) => {
                        showWindArrow = e.target.checked;
                        if (showWindArrow) {
                            windMarker.addTo(map);
                        } else {
                            map.removeLayer(windMarker);
                        }
                    });

                    document.getElementById('toggle-cog').addEventListener('change', (e) => {
                        showCogArrow = e.target.checked;
                        if (showCogArrow) {
                            cogMarker.addTo(map);
                        } else {
                            map.removeLayer(cogMarker);
                        }
                    });

                    document.getElementById('toggle-awa').addEventListener('change', (e) => {
                        showAwaArrow = e.target.checked;
                        if (showAwaArrow) {
                            awaMarker.addTo(map);
                        } else {
                            map.removeLayer(awaMarker);
                        }
                    });
                }

                // Create position markers
                if (allPoints.length > 0) {
                    const firstPoint = allPoints[0];

                    if (hasSailingData) {
                        // Create arrow markers for sailing data
                        const windArrowIcon = createArrowIcon(firstPoint.tws || 0, firstPoint.twa || 0, firstPoint.cog || 0);
                        windMarker = L.marker(
                            [firstPoint.lat, firstPoint.lon],
                            { icon: windArrowIcon }
                        ).addTo(map);

                        // Create COG arrow marker (green)
                        const cogArrowIcon = createCOGArrowIcon(firstPoint.sog || 0, firstPoint.cog || 0);
                        cogMarker = L.marker(
                            [firstPoint.lat, firstPoint.lon],
                            { icon: cogArrowIcon }
                        ).addTo(map);

                        // Create AWA arrow marker (orange)
                        const awaArrowIcon = createAWAArrowIcon(firstPoint.aws || 0, firstPoint.awa || 0, firstPoint.cog || 0);
                        awaMarker = L.marker(
                            [firstPoint.lat, firstPoint.lon],
                            { icon: awaArrowIcon }
                        ).addTo(map);
                    } else {
                        // Create position marker for GPX files (no sailing data)
                        // Use boat icon for water, person icon for land
                        const markerIcon = L.divIcon({
                            html: isOverWater ? '‚õµ' : 'üö∂',
                            iconSize: [32, 32],
                            className: 'boat-marker',
                            iconAnchor: [16, 16]
                        });
                        boatMarker = L.marker(
                            [firstPoint.lat, firstPoint.lon],
                            { icon: markerIcon }
                        ).addTo(map);
                    }

                    // Initialize data panel with first point
                    updateDataDisplay(firstPoint);

                    // Initialize position slider
                    const positionSlider = document.getElementById('position-slider');
                    positionSlider.max = allPoints.length - 1;
                    positionSlider.value = 0;
                    document.getElementById('position-info').textContent = `${firstPoint.utc} (1/${allPoints.length})`;
                }

                // Add position slider event listener
                document.getElementById('position-slider').addEventListener('input', (e) => {
                    const newIndex = parseInt(e.target.value);
                    currentIndex = newIndex;

                    if (allPoints.length > 0) {
                        const point = allPoints[currentIndex];

                        // Update position markers
                        if (hasSailingData) {
                            // Update arrows (only if sailing data available)
                            windMarker.setLatLng([point.lat, point.lon]);
                            const newWindArrowIcon = createArrowIcon(point.tws || 0, point.twa || 0, point.cog || 0);
                            windMarker.setIcon(newWindArrowIcon);

                            cogMarker.setLatLng([point.lat, point.lon]);
                            const newCOGArrowIcon = createCOGArrowIcon(point.sog || 0, point.cog || 0);
                            cogMarker.setIcon(newCOGArrowIcon);

                            awaMarker.setLatLng([point.lat, point.lon]);
                            const newAWAArrowIcon = createAWAArrowIcon(point.aws || 0, point.awa || 0, point.cog || 0);
                            awaMarker.setIcon(newAWAArrowIcon);

                            // Pan if enabled
                            if (panEnabled) {
                                map.panTo([point.lat, point.lon]);
                            }
                        } else {
                            // Update boat marker for GPX files
                            if (boatMarker) {
                                boatMarker.setLatLng([point.lat, point.lon]);

                                // Pan if enabled
                                if (panEnabled) {
                                    map.panTo([point.lat, point.lon]);
                                }
                            }
                        }

                        // Update data display
                        updateDataDisplay(point);

                        // Update distance from start to current position
                        calculateDistanceToCurrentPosition();

                        // Update position info with timestamp
                        document.getElementById('position-info').textContent = `${point.utc} (${currentIndex + 1}/${allPoints.length})`;
                    }
                });

                // No animation polyline - boat marker only to preserve original track visibility

                // Auto-load annotations only if tracks are from a directory (not uploaded files)
                if (isUploadedTracks) {
                    // Clear any existing annotations when using uploaded tracks
                    annotationMarkers.forEach(marker => map.removeLayer(marker));
                    annotationMarkers = [];
                    annotations = [];
                    updateAnnotationsList();
                    console.log('Uploaded tracks detected - annotations cleared (no directory association)');
                } else {
                    // Load annotations from track directory
                    await autoLoadAnnotations();
                }

            } catch (error) {
                console.error('Error loading tracks:', error);
                document.getElementById('loading').textContent = 'Error loading tracks!';
            }
        }


        // Animation functions
        function startAnimation() {
            if (animationInterval) return;

            document.getElementById('play-btn').disabled = true;
            document.getElementById('pause-btn').disabled = false;

            const baseDelay = 50; // Base delay in milliseconds
            const delay = baseDelay / speed;

            animationInterval = setInterval(() => {
                // Check bounds based on direction
                if (direction === 1 && currentIndex >= allPoints.length) {
                    stopAnimation();
                    return;
                }
                if (direction === -1 && currentIndex < 0) {
                    stopAnimation();
                    return;
                }

                const point = allPoints[currentIndex];

                // Update position markers
                if (hasSailingData) {
                    // Update arrow positions and icons (only if sailing data available)
                    // Update wind arrow position and icon (blue)
                    windMarker.setLatLng([point.lat, point.lon]);
                    const newWindArrowIcon = createArrowIcon(point.tws || 0, point.twa || 0, point.cog || 0);
                    windMarker.setIcon(newWindArrowIcon);

                    // Update COG arrow position and icon (green)
                    cogMarker.setLatLng([point.lat, point.lon]);
                    const newCOGArrowIcon = createCOGArrowIcon(point.sog || 0, point.cog || 0);
                    cogMarker.setIcon(newCOGArrowIcon);

                    // Update AWA arrow position and icon (orange)
                    awaMarker.setLatLng([point.lat, point.lon]);
                    const newAWAArrowIcon = createAWAArrowIcon(point.aws || 0, point.awa || 0, point.cog || 0);
                    awaMarker.setIcon(newAWAArrowIcon);

                    // Pan map to center on current position if enabled
                    if (panEnabled) {
                        map.panTo([point.lat, point.lon]);
                    }
                } else {
                    // Update simple boat marker for GPX files
                    if (boatMarker) {
                        boatMarker.setLatLng([point.lat, point.lon]);

                        // Pan map to center on current position if enabled
                        if (panEnabled) {
                            map.panTo([point.lat, point.lon]);
                        }
                    }
                }

                // Update info in bottom bar and right sidebar
                document.getElementById('progress-info').textContent =
                    `Point ${currentIndex + 1} of ${allPoints.length} (${((currentIndex / allPoints.length) * 100).toFixed(1)}%)`;

                // Update data panel in sidebar
                updateDataDisplay(point);

                // Update distance from start to current position
                calculateDistanceToCurrentPosition();

                // Update position slider
                document.getElementById('position-slider').value = currentIndex;
                document.getElementById('position-info').textContent = `${point.utc} (${currentIndex + 1}/${allPoints.length})`;

                currentIndex += direction;
            }, delay);
        }

        function pauseAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
                document.getElementById('play-btn').disabled = false;
                document.getElementById('pause-btn').disabled = true;
            }
        }

        function stopAnimation() {
            pauseAnimation();
            document.getElementById('progress-info').textContent = 'Animation complete!';
        }

        function resetAnimation() {
            pauseAnimation();
            currentIndex = 0;
            direction = 1;

            // Reset Reverse button appearance
            const reverseBtn = document.getElementById('reverse-btn');
            reverseBtn.style.background = '#007bff';
            reverseBtn.textContent = 'Reverse';

            if (allPoints.length > 0) {
                const firstPoint = allPoints[0];

                // Update position markers
                if (hasSailingData) {
                    // Update arrows (only if sailing data available)
                    windMarker.setLatLng([firstPoint.lat, firstPoint.lon]);
                    cogMarker.setLatLng([firstPoint.lat, firstPoint.lon]);
                    awaMarker.setLatLng([firstPoint.lat, firstPoint.lon]);
                } else {
                    // Update boat marker for GPX files
                    if (boatMarker) {
                        boatMarker.setLatLng([firstPoint.lat, firstPoint.lon]);
                    }
                }

                // Center map at start position
                map.panTo([firstPoint.lat, firstPoint.lon]);

                // Update data display
                updateDataDisplay(firstPoint);

                // Update distance (should be 0 at start)
                calculateDistanceToCurrentPosition();

                // Update position slider
                document.getElementById('position-slider').value = 0;
                document.getElementById('position-info').textContent = `${firstPoint.utc} (1/${allPoints.length})`;
            }

            document.getElementById('progress-info').textContent = 'Ready to play';
            document.getElementById('play-btn').disabled = false;
        }

        // Event listeners
        document.getElementById('play-btn').addEventListener('click', startAnimation);
        document.getElementById('pause-btn').addEventListener('click', pauseAnimation);
        document.getElementById('reset-btn').addEventListener('click', resetAnimation);

        document.getElementById('pan-btn').addEventListener('click', () => {
            panEnabled = !panEnabled;
            const btn = document.getElementById('pan-btn');
            if (panEnabled) {
                btn.style.background = '#28a745';
                btn.textContent = 'Pan: ON';
            } else {
                btn.style.background = '#007bff';
                btn.textContent = 'Pan';
            }
        });

        document.getElementById('reverse-btn').addEventListener('click', () => {
            direction = -direction;
            const btn = document.getElementById('reverse-btn');
            if (direction === -1) {
                btn.style.background = '#ffc107';
                btn.textContent = 'Reverse: ON';
            } else {
                btn.style.background = '#007bff';
                btn.textContent = 'Reverse';
            }

            // Restart animation with new direction if currently playing
            if (animationInterval) {
                pauseAnimation();
                startAnimation();
            }
        });

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);
            speed = getSpeedMultiplier(sliderValue);
            document.getElementById('speed-value').textContent = getSpeedLabel(sliderValue);

            // Restart animation with new speed if currently playing
            if (animationInterval) {
                pauseAnimation();
                startAnimation();
            }
        });

        // Convert GPS coordinates from EXIF format to decimal degrees
        function convertDMSToDD(degrees, minutes, seconds, direction) {
            let dd = degrees + minutes / 60 + seconds / 3600;
            if (direction === 'S' || direction === 'W') {
                dd = dd * -1;
            }
            return dd;
        }

        // Format EXIF date to yyyy-mm-dd HH:MM:SS
        function formatExifDate(exifDate) {
            if (!exifDate) return '';
            // EXIF format is "YYYY:MM:DD HH:MM:SS"
            // Convert to "YYYY-MM-DD HH:MM:SS"
            return exifDate.replace(/^(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3');
        }

        // Parse timestamp from filename
        // Supports common formats like: 20251009_154621, IMG_20251009_154621, VID-20251009-154621, etc.
        function parseTimestampFromFilename(filename) {
            // Remove extension
            const nameWithoutExt = filename.replace(/\.[^/.]+$/, '');

            console.log(`  Attempting to parse timestamp from filename: ${nameWithoutExt}`);

            // Pattern 1: YYYYMMDD_HHMMSS (e.g., 20251009_154621)
            let match = nameWithoutExt.match(/(\d{4})(\d{2})(\d{2})[_-](\d{2})(\d{2})(\d{2})/);
            if (match) {
                const [, year, month, day, hour, min, sec] = match;
                const dateStr = `${year}-${month}-${day}T${hour}:${min}:${sec}`;
                console.log(`  ‚úÖ Parsed from pattern YYYYMMDD_HHMMSS: ${dateStr}`);
                return new Date(dateStr);
            }

            // Pattern 2: YYYY-MM-DD_HH-MM-SS or YYYY-MM-DD HH-MM-SS
            match = nameWithoutExt.match(/(\d{4})-(\d{2})-(\d{2})[_\s-]+(\d{2})-(\d{2})-(\d{2})/);
            if (match) {
                const [, year, month, day, hour, min, sec] = match;
                const dateStr = `${year}-${month}-${day}T${hour}:${min}:${sec}`;
                console.log(`  ‚úÖ Parsed from pattern YYYY-MM-DD_HH-MM-SS: ${dateStr}`);
                return new Date(dateStr);
            }

            // Pattern 3: YYYYMMDD only (e.g., 20251009)
            match = nameWithoutExt.match(/(\d{4})(\d{2})(\d{2})/);
            if (match) {
                const [, year, month, day] = match;
                const dateStr = `${year}-${month}-${day}T12:00:00`;
                console.log(`  ‚úÖ Parsed from pattern YYYYMMDD (date only, assuming noon): ${dateStr}`);
                return new Date(dateStr);
            }

            console.log(`  ‚ùå Could not parse timestamp from filename`);
            return null;
        }

        // Extract video metadata creation date using video element
        async function getVideoCreationDate(file) {
            return new Promise((resolve) => {
                const video = document.createElement('video');
                video.preload = 'metadata';

                video.onloadedmetadata = function() {
                    // Try to get creation date from video metadata
                    // Note: This is limited in browsers, but we can try
                    URL.revokeObjectURL(video.src);

                    // Unfortunately, browser video elements don't expose creation time directly
                    // We'll need to rely on filename parsing or file modification time
                    resolve(null);
                };

                video.onerror = function() {
                    URL.revokeObjectURL(video.src);
                    resolve(null);
                };

                video.src = URL.createObjectURL(file);
            });
        }

        // Open photo/video modal with full resolution
        function openPhotoModal(mediaSrc, fileName, dateTime, isVideo = false, mimeType = '') {
            const modal = document.getElementById('photo-modal');
            const modalImg = document.getElementById('modal-image');
            const modalVideo = document.getElementById('modal-video');
            const modalVideoSource = document.getElementById('modal-video-source');
            const modalInfo = document.getElementById('modal-info');

            modal.style.display = 'block';

            if (isVideo) {
                // Show video, hide image
                modalImg.style.display = 'none';
                modalVideo.style.display = 'block';
                modalVideoSource.src = mediaSrc;
                modalVideoSource.type = mimeType;
                modalVideo.load();
            } else {
                // Show image, hide video
                modalVideo.style.display = 'none';
                modalImg.style.display = 'block';
                modalImg.src = mediaSrc;
            }

            const formattedDate = formatExifDate(dateTime);
            modalInfo.innerHTML = `<div>${fileName}</div>${formattedDate ? `<div style="font-size: 12px; margin-top: 5px;">${formattedDate}</div>` : ''}`;
        }

        // Close photo/video modal
        function closePhotoModal() {
            const modal = document.getElementById('photo-modal');
            const modalVideo = document.getElementById('modal-video');

            // Pause and reset video if it was playing
            if (modalVideo.style.display !== 'none') {
                modalVideo.pause();
                modalVideo.currentTime = 0;
            }

            modal.style.display = 'none';
        }

        // Close modal when clicking outside the image
        window.onclick = function(event) {
            const modal = document.getElementById('photo-modal');
            if (event.target === modal) {
                closePhotoModal();
            }
        }

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closePhotoModal();
            }
        });

        // Handle photo and video upload and extract GPS data
        function handlePhotoUpload(event) {
            const files = event.target.files;
            if (files.length === 0) return;

            let photosLoaded = 0;
            let videosLoaded = 0;
            let mediaProcessed = 0;
            let mediaFiltered = 0;
            let photosFiltered = 0;
            let videosFiltered = 0;
            let videosNoMatch = 0;
            let totalVideoFiles = 0;
            let totalPhotoFiles = 0;

            // Check filter setting at start
            const filterByTime = document.getElementById('filter-photos-by-time').checked;
            console.log(`Media upload started. Filter by time: ${filterByTime}`);
            console.log(`Processing ${files.length} files`);

            // Clear existing photo/video markers
            photoMarkers.forEach(marker => map.removeLayer(marker));
            photoMarkers = [];

            // Get track timestamp range for filtering
            let trackStartTime = null;
            let trackEndTime = null;
            if (allPoints.length > 0) {
                const timestamps = allPoints.map(p => p.utc).filter(t => t);
                if (timestamps.length > 0) {
                    const times = timestamps.map(t => new Date(t)).filter(d => !isNaN(d.getTime()));
                    if (times.length > 0) {
                        trackStartTime = new Date(Math.min(...times.map(d => d.getTime())));
                        trackEndTime = new Date(Math.max(...times.map(d => d.getTime())));
                    }
                }
            }

            Array.from(files).forEach(file => {
                const isVideo = file.type.startsWith('video/');
                const isImage = file.type.startsWith('image/');

                if (!isImage && !isVideo) return;

                if (isVideo) totalVideoFiles++;
                if (isImage) totalPhotoFiles++;

                const reader = new FileReader();
                reader.onload = function(e) {
                    if (isImage) {
                        // Process image file
                        const img = new Image();
                        img.src = e.target.result;

                        img.onload = function() {
                            EXIF.getData(img, function() {
                                const lat = EXIF.getTag(this, 'GPSLatitude');
                                const latRef = EXIF.getTag(this, 'GPSLatitudeRef');
                                const lon = EXIF.getTag(this, 'GPSLongitude');
                                const lonRef = EXIF.getTag(this, 'GPSLongitudeRef');
                                const dateTime = EXIF.getTag(this, 'DateTime');

                                mediaProcessed++;

                                if (lat && lon && latRef && lonRef) {
                                    const latitude = convertDMSToDD(lat[0], lat[1], lat[2], latRef);
                                    const longitude = convertDMSToDD(lon[0], lon[1], lon[2], lonRef);

                                    console.log(`Photo ${file.name}: GPS found [${latitude}, ${longitude}], DateTime: ${dateTime || 'none'}`);

                                // Filter photos by track timestamp range if checkbox is enabled
                                let includePhoto = true;
                                const filterByTime = document.getElementById('filter-photos-by-time').checked;

                                if (filterByTime && trackStartTime && trackEndTime && dateTime) {
                                    const formattedDate = formatExifDate(dateTime);
                                    const photoTime = new Date(formattedDate);
                                    console.log(`  üìÖ Photo timestamp from EXIF: ${photoTime.toISOString()}`);
                                    if (!isNaN(photoTime.getTime())) {
                                        if (photoTime < trackStartTime || photoTime > trackEndTime) {
                                            includePhoto = false;
                                            photosFiltered++;
                                            const beforeStart = photoTime < trackStartTime;
                                            const timeDiff = beforeStart
                                                ? Math.round((trackStartTime - photoTime) / 1000 / 60 / 60 / 24)
                                                : Math.round((photoTime - trackEndTime) / 1000 / 60 / 60 / 24);
                                            console.log(`  ‚ùå FILTERED OUT: Photo is ${beforeStart ? 'before' : 'after'} track time by ${timeDiff} days`);
                                        } else {
                                            console.log(`  ‚úÖ INCLUDED (within track time)`);
                                        }
                                    }
                                } else {
                                    console.log(`  ‚úÖ INCLUDED (no filtering applied)`);
                                }

                                    if (includePhoto) {
                                        // Create camera icon for photo marker
                                        const photoIcon = L.divIcon({
                                            html: 'üì∑',
                                            iconSize: [24, 24],
                                            className: 'photo-marker',
                                            iconAnchor: [12, 12]
                                        });

                                        // Add marker to map - clicking marker opens full-res photo
                                        const marker = L.marker([latitude, longitude], { icon: photoIcon })
                                            .addTo(map)
                                            .on('click', function() {
                                                openPhotoModal(e.target.result, file.name, dateTime, false);
                                            });

                                        // Create popup with photo thumbnail (clicking thumbnail also opens full-res)
                                        const formattedDate = formatExifDate(dateTime);
                                        const popupContent = `
                                            <div style="text-align: center; cursor: pointer;" onclick="openPhotoModal('${e.target.result}', '${file.name}', '${dateTime || ''}', false)">
                                                <img src="${e.target.result}" style="max-width: 200px; max-height: 200px; display: block; margin-bottom: 5px;">
                                                <div style="font-size: 11px; color: #666;">${file.name}</div>
                                                ${formattedDate ? `<div style="font-size: 10px; color: #999;">${formattedDate}</div>` : ''}
                                                <div style="font-size: 9px; color: #007bff; margin-top: 3px;">Click to view full size</div>
                                            </div>
                                        `;
                                        marker.bindPopup(popupContent);

                                        photoMarkers.push(marker);
                                        photosLoaded++;
                                    } else {
                                        photosFiltered++;
                                    }
                                } else {
                                    // Photo has no GPS coordinates
                                    // Try to position by timestamp if DateTime is available
                                    console.log(`Photo ${file.name}: No GPS data`);

                                    if (dateTime && allPoints.length > 0 && trackStartTime && trackEndTime) {
                                        const formattedDate = formatExifDate(dateTime);
                                        const photoTime = new Date(formattedDate);

                                        if (!isNaN(photoTime.getTime())) {
                                            console.log(`  üìÖ Photo timestamp from EXIF: ${photoTime.toISOString()}`);

                                            // Check filtering
                                            const filterByTime = document.getElementById('filter-photos-by-time').checked;
                                            if (filterByTime && (photoTime < trackStartTime || photoTime > trackEndTime)) {
                                                photosFiltered++;
                                                console.log(`  ‚ùå FILTERED OUT (outside track time)`);
                                                updateMediaStatus();
                                                return;
                                            }

                                            // Find closest track point by timestamp
                                            let closestPoint = null;
                                            let minTimeDiff = Infinity;

                                            allPoints.forEach(point => {
                                                if (point.utc) {
                                                    const pointTime = new Date(point.utc);
                                                    const timeDiff = Math.abs(photoTime - pointTime);
                                                    if (timeDiff < minTimeDiff) {
                                                        minTimeDiff = timeDiff;
                                                        closestPoint = point;
                                                    }
                                                }
                                            });

                                            if (closestPoint && minTimeDiff < 3600000) { // Within 1 hour
                                                console.log(`  ‚úÖ Positioned by timestamp at [${closestPoint.lat.toFixed(6)}, ${closestPoint.lon.toFixed(6)}]`);

                                                const photoIcon = L.divIcon({
                                                    html: 'üì∑',
                                                    iconSize: [24, 24],
                                                    className: 'photo-marker',
                                                    iconAnchor: [12, 12]
                                                });

                                                const marker = L.marker([closestPoint.lat, closestPoint.lon], { icon: photoIcon })
                                                    .addTo(map)
                                                    .on('click', function() {
                                                        openPhotoModal(e.target.result, file.name, dateTime, false);
                                                    });

                                                const popupContent = `
                                                    <div style="text-align: center; cursor: pointer;" onclick="openPhotoModal('${e.target.result}', '${file.name}', '${dateTime || ''}', false)">
                                                        <img src="${e.target.result}" style="max-width: 200px; max-height: 200px; display: block; margin-bottom: 5px;">
                                                        <div style="font-size: 11px; color: #666;">${file.name}</div>
                                                        <div style="font-size: 10px; color: #999;">${formattedDate}</div>
                                                        <div style="font-size: 9px; color: #007bff; margin-top: 3px;">Click to view full size</div>
                                                    </div>
                                                `;
                                                marker.bindPopup(popupContent);

                                                photoMarkers.push(marker);
                                                photosLoaded++;
                                            } else {
                                                console.log(`  ‚ùå No close track point found (timestamp >1hr away)`);
                                            }
                                        }
                                    } else {
                                        console.log(`  ‚ùå Cannot position photo: no GPS and no timestamp/track data`);
                                    }
                                }

                                updateMediaStatus();
                            });
                        };
                    } else if (isVideo) {
                        // Process video file - try to extract metadata
                        // Priority: 1) Filename timestamp, 2) Video metadata, 3) File modification time
                        mediaProcessed++;

                        console.log(`\n=== Processing Video: ${file.name} ===`);
                        console.log(`  File size: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
                        console.log(`  File type: ${file.type}`);

                        // Try to parse timestamp from filename first
                        let videoDate = parseTimestampFromFilename(file.name);

                        if (!videoDate) {
                            // Fall back to file modification time
                            videoDate = new Date(file.lastModified);
                            console.log(`  ‚ö†Ô∏è Using file modification timestamp (fallback): ${videoDate.toISOString()}`);
                        }

                        const fileDate = videoDate;
                        console.log(`  üìÖ Using timestamp: ${fileDate.toISOString()}`);

                        // Try to find a track position close to the video timestamp
                        let videoPosition = null;
                        if (allPoints.length === 0) {
                            console.log(`  ‚ùå ERROR: No track data loaded! Load track files first.`);
                            videosNoMatch++;
                            updateMediaStatus();
                            return;
                        }

                        if (!trackStartTime || !trackEndTime) {
                            console.log(`  ‚ùå ERROR: Track has no timestamps!`);
                            videosNoMatch++;
                            updateMediaStatus();
                            return;
                        }

                        console.log(`  Track time range: ${trackStartTime.toISOString()} to ${trackEndTime.toISOString()}`);
                        console.log(`  Filter by time enabled: ${filterByTime}`);

                        // Check if video timestamp is within track time range
                        if (filterByTime && (fileDate < trackStartTime || fileDate > trackEndTime)) {
                            const beforeStart = fileDate < trackStartTime;
                            const timeDiff = beforeStart
                                ? Math.round((trackStartTime - fileDate) / 1000 / 60 / 60 / 24)
                                : Math.round((fileDate - trackEndTime) / 1000 / 60 / 60 / 24);
                            videosFiltered++;
                            console.log(`  ‚ùå FILTERED OUT: Video is ${beforeStart ? 'before' : 'after'} track time by ${timeDiff} days`);
                            console.log(`  üí° TIP: Uncheck "Only show photos/videos taken during track time" to load all videos`);
                            updateMediaStatus();
                            return;
                        }

                        // Find closest track point by timestamp
                        let closestPoint = null;
                        let minTimeDiff = Infinity;

                        allPoints.forEach(point => {
                            if (point.utc) {
                                const pointTime = new Date(point.utc);
                                const timeDiff = Math.abs(fileDate - pointTime);
                                if (timeDiff < minTimeDiff) {
                                    minTimeDiff = timeDiff;
                                    closestPoint = point;
                                }
                            }
                        });

                        if (closestPoint) {
                            const hoursDiff = minTimeDiff / 1000 / 60 / 60;
                            const daysDiff = minTimeDiff / 1000 / 60 / 60 / 24;

                            if (minTimeDiff < 3600000) { // Within 1 hour
                                videoPosition = { lat: closestPoint.lat, lon: closestPoint.lon };
                                console.log(`  ‚úÖ SUCCESS: Matched to track position [${videoPosition.lat.toFixed(6)}, ${videoPosition.lon.toFixed(6)}]`);
                                console.log(`  Time difference: ${Math.round(minTimeDiff/1000)} seconds (${hoursDiff.toFixed(1)} hours)`);
                            } else {
                                console.log(`  ‚ùå NO MATCH: Closest track point is ${hoursDiff.toFixed(1)} hours away (${daysDiff.toFixed(1)} days)`);
                                console.log(`  Current limit: 1 hour. Video timestamp: ${fileDate.toISOString()}`);
                                console.log(`  Closest track point: ${new Date(closestPoint.utc).toISOString()}`);
                                console.log(`  üí° TIP: Video file timestamp may not match recording time. Check file properties.`);
                                videosNoMatch++;
                                updateMediaStatus();
                                return;
                            }
                        } else {
                            console.log(`  ‚ùå ERROR: No track points with timestamps found`);
                            videosNoMatch++;
                            updateMediaStatus();
                            return;
                        }

                        if (videoPosition) {
                            // Create video icon for marker
                            const videoIcon = L.divIcon({
                                html: 'üé•',
                                iconSize: [24, 24],
                                className: 'video-marker',
                                iconAnchor: [12, 12]
                            });

                            // Add marker to map - clicking marker opens video player
                            const marker = L.marker([videoPosition.lat, videoPosition.lon], { icon: videoIcon })
                                .addTo(map)
                                .on('click', function() {
                                    openPhotoModal(e.target.result, file.name, fileDate.toISOString(), true, file.type);
                                });

                            // Create popup with video thumbnail
                            const formattedDate = fileDate.toISOString().replace('T', ' ').substring(0, 19);
                            const popupContent = `
                                <div style="text-align: center; cursor: pointer;" onclick="openPhotoModal('${e.target.result}', '${file.name}', '${fileDate.toISOString()}', true, '${file.type}')">
                                    <div style="max-width: 200px; max-height: 200px; display: flex; align-items: center; justify-content: center; background: #000; margin-bottom: 5px;">
                                        <div style="font-size: 48px;">üé•</div>
                                    </div>
                                    <div style="font-size: 11px; color: #666;">${file.name}</div>
                                    <div style="font-size: 10px; color: #999;">${formattedDate}</div>
                                    <div style="font-size: 9px; color: #007bff; margin-top: 3px;">Click to play video</div>
                                </div>
                            `;
                            marker.bindPopup(popupContent);

                            photoMarkers.push(marker);
                            videosLoaded++;
                        }

                        updateMediaStatus();
                    }
                };
                reader.readAsDataURL(file);
            });

            // Helper function to update status display
            function updateMediaStatus() {
                if (mediaProcessed === files.length) {
                    const filterByTime = document.getElementById('filter-photos-by-time').checked;
                    const totalLoaded = photosLoaded + videosLoaded;
                    const totalFiltered = photosFiltered + videosFiltered;

                    let statusParts = [];

                    // Main count
                    if (photosLoaded > 0 && videosLoaded > 0) {
                        statusParts.push(`Loaded ${photosLoaded} photo${photosLoaded !== 1 ? 's' : ''} and ${videosLoaded} video${videosLoaded !== 1 ? 's' : ''}`);
                    } else if (photosLoaded > 0) {
                        statusParts.push(`Loaded ${photosLoaded} photo${photosLoaded !== 1 ? 's' : ''}`);
                    } else if (videosLoaded > 0) {
                        statusParts.push(`Loaded ${videosLoaded} video${videosLoaded !== 1 ? 's' : ''}`);
                    } else {
                        statusParts.push(`No photos or videos loaded`);
                    }

                    // Filtering info
                    if (filterByTime && totalFiltered > 0) {
                        let filterDetails = [];
                        if (photosFiltered > 0) filterDetails.push(`${photosFiltered} photo${photosFiltered !== 1 ? 's' : ''}`);
                        if (videosFiltered > 0) filterDetails.push(`${videosFiltered} video${videosFiltered !== 1 ? 's' : ''}`);
                        statusParts.push(`(${filterDetails.join(', ')} filtered - outside track time)`);
                    }

                    // Videos that didn't match
                    if (videosNoMatch > 0) {
                        statusParts.push(`(${videosNoMatch} video${videosNoMatch !== 1 ? 's' : ''} skipped - timestamp >1hr from track)`);
                    }

                    document.getElementById('photo-status').textContent = statusParts.join(' ');

                    // Console summary
                    console.log('\n=== MEDIA LOADING SUMMARY ===');
                    console.log(`Total files: ${files.length} (${totalPhotoFiles} photos, ${totalVideoFiles} videos)`);
                    console.log(`Loaded: ${totalLoaded} (${photosLoaded} photos, ${videosLoaded} videos)`);
                    if (totalFiltered > 0) {
                        console.log(`Filtered: ${totalFiltered} (${photosFiltered} photos, ${videosFiltered} videos) - outside track time range`);
                    }
                    if (videosNoMatch > 0) {
                        console.log(`Not matched: ${videosNoMatch} videos - timestamp more than 1 hour from any track point`);
                        console.log(`üí° Check browser console above for details on each video`);
                    }
                    console.log('============================\n');

                    // Reset file input so user can re-select the same files
                    event.target.value = '';
                }
            }
        }

        // Add event listener for photo upload
        document.getElementById('photo-upload').addEventListener('change', handlePhotoUpload);

        // Initialize on page load
        window.addEventListener('load', initMap);

        // Resize handle functionality
        (function() {
            const resizeHandle = document.getElementById('resize-handle');
            const sidebar = document.getElementById('right-sidebar');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            resizeHandle.addEventListener('mousedown', function(e) {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;

                // Calculate new width (subtract because we're dragging from the left edge)
                const diff = startX - e.clientX;
                const newWidth = startWidth + diff;

                // Apply constraints
                const minWidth = 200;
                const maxWidth = 600;
                const constrainedWidth = Math.min(Math.max(newWidth, minWidth), maxWidth);

                sidebar.style.width = constrainedWidth + 'px';

                // Invalidate map size so Leaflet adjusts
                if (map) {
                    setTimeout(() => map.invalidateSize(), 0);
                }
            });

            document.addEventListener('mouseup', function() {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });

            // Touch support for mobile
            resizeHandle.addEventListener('touchstart', function(e) {
                isResizing = true;
                startX = e.touches[0].clientX;
                startWidth = sidebar.offsetWidth;
                e.preventDefault();
            });

            document.addEventListener('touchmove', function(e) {
                if (!isResizing) return;

                const diff = startX - e.touches[0].clientX;
                const newWidth = startWidth + diff;

                const minWidth = 200;
                const maxWidth = 600;
                const constrainedWidth = Math.min(Math.max(newWidth, minWidth), maxWidth);

                sidebar.style.width = constrainedWidth + 'px';

                if (map) {
                    setTimeout(() => map.invalidateSize(), 0);
                }
            });

            document.addEventListener('touchend', function() {
                if (isResizing) {
                    isResizing = false;
                }
            });
        })();
    </script>
</body>
</html>
